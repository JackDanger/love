<nzai>
  <page name="Overview" file="index.html">
    <section name="Welcome">


      Welcome to the official L&amp;Ouml;VE documentation page. Here we have explanations of all the types and objects available for the Lua scripting.
      This does not describe the inner-workings of the engine itself (but we do have an SVN repository available on SourceForge if that's what you're looking for).
      To understand anything that's going on it is recommended that you have a little bit of programming experience, but hopefully LÖVE is straight-forward and simple
      enough for even novices to get into game creation.
      [br /][br /]
      We believe that thorough documentation is important for the survival of a program so if there is something missing or incorrect, please
      [a href="http://love2d.org/?page=credits"]contact us[/a].
    </section>
    <section name="Tutorials">
      This page has the bare documentation and, except for the simple examples, contain no actual tutorials.
      Tutorials are available from the tutorial page on the [a href="http://love2d.org/?page=documentation"]LÖVE website[/a].
    </section>
  </page>
  <page name="License">
    <section name="Summary">

      L&amp;Ouml;VE (the software) is licensed under the terms of the ZLIB license. This is
      a very liberal license with permits almost anything.[br /]
      [br /]
      The documentation is licensed under the The FreeBSD Documentation license. This is similar to
      ZLIB, but meant for written documents as opposed to software.
    </section>
    <section name="ZLIB license (full)">

      Copyright &amp;copy; 2006-2008 L&amp;Ouml;VE Development Team[br /]
      [br /]
      This software is provided 'as-is', without any express or implied
      warranty. In no event will the authors be held liable for any damages
      arising from the use of this software.[br /]
      [br /]
      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute it
      freely, subject to the following restrictions:[br /]
      [br /]
      1. The origin of this software must not be misrepresented; you must not
      claim that you wrote the original software. If you use this software
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.[br /]
      [br /]
      2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original software.[br /]
      [br /]
      3. This notice may not be removed or altered from any source
      distribution.[br /]

    </section>
    <section name="The FreeBSD Documentation license">

      Copyright &amp;copy; 2006-2008 L&amp;Ouml;VE Development Team. All rights reserved.[br /]
      [br /]
      Redistribution and use in source (XML) and compiled forms (HTML) with or without modification,
      are permitted provided that the following conditions are met:[br /]
      [br /]

      1. Redistributions of source code (XML) must retain the above copyright notice,
      this list of conditions and the following disclaimer as the first lines of this file unmodified.[br /]
      [br /]

      2. Redistributions in compiled form (HTML) must reproduce the above copyright notice, this list of conditions and
      the following disclaimer in the documentation and/or other materials provided with the distribution.[br /]
      [br /]

      THIS DOCUMENTATION IS PROVIDED BY THE LOVE DEVELOPMENT TEAM "AS IS" AND ANY EXPRESS OR
      IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LOVE DEVELOPMENT TEAM
      BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
      PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
      CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
      OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    </section>
  </page>
  <page name="Credits">
    <section name="Authors">
      LÖVE is created by:[br /]
      [ul]
      [li]Anders Ruud - andruud at gmail dot com[/li]
      [li]Michael Enger - mike at facemeandscream dot com[/li]
      [li]Tommy Nguyen - tn0502 at hotmail dot com[/li]
      [/ul]
    </section>

    <section name="Libraries">
      LÖVE is built around these libraries, presented here in no particular order:

      [ul]
      [li][a href="http://www.boost.org/"]boost[/a] - General purpose C++ libraries.[/li]
      [li][a href="http://libsdl.org/"]SDL[/a] - OS abstraction, mouse input, keyboard input.[/li]
      [li][a href="http://lua.org/"]Lua[/a] - Scripting.[/li]
      [li][a href="http://opengl.org/"]OpenGL[/a] - Hardware accelerated graphics.[/li]
      [li][a href="http://openil.sourceforge.net/"]DevIL[/a] - Image loading.[/li]
      [li][a href="http://www.freetype.org/"]FreeType 2[/a] - Font loading and rasterization.[/li]
      [li][a href="http://www.libsdl.org/projects/SDL_mixer/"]SDL_mixer[/a] - Sound loading/playing.[/li]
      [li][a href="http://icculus.org/physfs/"]PhysicsFS[/a] - Filesystem management + support for archive files.[/li]

      [/ul]

      A behemothic thanks to all of these.

    </section>


  </page>
  <page name="Installing">

    <section name="Binaries">
      We currently maintain x86 binaries for:
      [ul]
      [li]Windows XP/Vista (zipped .exe and installer)[/li]
      [li]Ubuntu 8.04 (.deb package. May work on other Debian-based OS.)[/li]
      [/ul]

      Using the binaries is highly recommended, if available on your system.[br /]
      [br /]
      Binaries and packages for other systems (MacOSX, RPM) are planned.
      If you would like to maintain binaries for some system, please [a href="http://love2d.org/?page=credits"]contact us[/a].
    </section>

    <section name="Source">

      Compiling the source requires that these libraries are present on your system (as named in Ubuntu):

      [ul]
      [li]libboost-dev[/li]
      [li]libsdl1.2-dev[/li]
      [li]liblua5.1-dev[/li]
      [li]libfreetype6-dev[/li]
      [li]libdevil-dev[/li]
      [li]libphysfs-dev[/li]
      [li]libsdl-mixer1.2-dev[/li]
      [/ul]

      In Ubuntu, the following command will install the required packages.
      [code]
      sudo apt-get install build-essential libboost-dev libsdl1.2-dev liblua5.1-dev libfreetype6-dev libdevil-dev libphysfs-dev libsdl-mixer1.2-dev
      [/code]
      When the dependencies are installed, all you need to do is type:
      [code]
      make
      [/code]

      Binaries will appear in the bin folder.[br /]
      [br /]
      Note: An autoconf/automake setup is being created, and will probably be included in the next release.
    </section>
  </page>
  <page name="Getting started">
    <section name="Basics">
      Download LÖVE from [a href="http://love2d.org"]http://love2d.org[/a] and install.[br /]
      [br /]
      Create a new directory somewhere, and create two files:

      [ul]
      [li]main.lua - main file containing the game code.[/li]
      [li]game.conf - optional (but recommended) support file that contains info about your game.[/li]
      [/ul]

      Write the following into the game.conf file:
      [code]
      author = "Your Name"[br /]
      title = "My Awesome Game"
      [/code]

      And write the following into the main.lua file:
      [code]
      function load()[br /]
      &amp;nbsp;&amp;nbsp;&amp;nbsp;font = love.graphics.newFont(love.default_font, 12)[br /]
      &amp;nbsp;&amp;nbsp;&amp;nbsp;love.graphics.setFont(font)[br /]
      &amp;nbsp;&amp;nbsp;&amp;nbsp;message = "Yharrr, Why hello thaarrrr!"[br /]
      end[br /]
      [br /]
      function draw()[br /]
      &amp;nbsp;&amp;nbsp;&amp;nbsp;love.graphics.draw(message, 100, 100)[br /]
      end
      [/code]


      After saving, simply drag the directory you created onto the executable
      (Windows: love.exe), and the the game will start. You should see your
      message on the screen.
    </section>


    <section name="Further Reading">
      For more information, check out the [a href="http://love2d.org/?page=documentation"]tutorials[/a].
    </section>

    <section name="External libraries">

      LOVE uses many libraries, such as SDL, DevIL and FreeType. These all have their own licenses.
      An overview is presented here.

      [ul]
      [li]boost ([a href="http://www.boost.org/users/license.html"]BSL[/a])[/li]
      [li]SDL ([a href="http://www.opensource.org/licenses/lgpl-license.php"]LGPL[/a])[/li]
      [li]SDL_mixer ([a href="http://www.opensource.org/licenses/lgpl-license.php"]LGPL[/a])[/li]
      [li]DevIL ([a href="http://www.opensource.org/licenses/lgpl-license.php"]LGPL[/a])[/li]
      [li]FreeType 2 ([a href="http://www.freetype.org/FTL.TXT"]FTL[/a])[/li]
      [li]PhysFS ([a href="http://www.opensource.org/licenses/zlib-license.php"]ZLIB[/a])[/li]
      [li]Lua ([a href="http://www.opensource.org/licenses/mit-license.html"]MIT[/a])[/li]
      [/ul]

    </section>


  </page>
  <page name="Manual Improvements">
    <section name="Contact Us">
      If you have suggestions as to how the manual can be improved,
      please don't hesitate to [a href="http://love2d.org/?page=credits"]contact us[/a].
      That goes for things like:
      [ul]
      [li]Corrections.[/li]
      [li]Example requests. [/li]
      [li]Rephrasing.[/li]
      [li]Presentation improvements.[/li]
      [/ul]
      Or anything else you can think of. (These are just examples).

    </section>
    <section name="Submit An Example">
      Most pages in the documentation does currently not contain examples. Eventually, [i]all[/i]
      items will have at least one example, but that represents way too much work as a
      pre-release activity. Instead, the plan is to gradually add examples as people are bothered to
      create them, or when the need emerges.[br /]
      [br /]
      If you would like to contribute to the documentation by adding an example, please [a href="http://love2d.org/?page=credits"]contact us[/a]!
      Do note the following, however:
      [ul]
      [li]The example must be runnable.[/li]
      [li]Keep it short.[/li]
      [li]Let us know where you want the example present. The same example can be displayed on multiple pages.[/li]
      [li]If you need to use Images, Sounds or other resoures,
      check if you can use something already present in
      [a href="http://love2d.org/examples/images"]/examples/images[/a] and similar
      folders. Otherwise, you can submit a resource, but keep it small, and make sure it's free.[/li]
      [/ul]
      Thanks!
    </section>
  </page>

  <page name="Game Distribution">
    <section name="Introduction">
      Many people are (understandably) concerned about what end-users need to do in order
      to run a LOVE-game. If users recieve a .love-file alone, they will naturally need
      LOVE installed (or at least unzipped) in order to run it. But, as of LOVE 0.5.0, you can
      merge the .love file with the love exeutable.
      [br /][br /]
      In general, it's recommended to offer a .love for download, and optionally "merged" versions for the
      platforms where this makes things simpler.
      [br /][br /]
      Two things should be noted:
      [ol]
      [li]The end result will not be a single executable, you must also include some DDLs in your zip-file.[/li]
      [li]The resulting executable from the merge will still be readable by archiving software, such as WinZip.[/li]
      [/ol]
    </section>
    <section name="Windows">
      Here's how to do it on Windows. In a console, type this:
      [code]
      copy /b love.exe+game.love game.exe
      [/code]
      Then, all you have to do is zip game.exe and required DLLs, and distribute them. Yes; this does mean that the game will have a
      private copy of LOVE, but there's nothing wrong with that. It also means that you will have to create one package for
      each platform you would like to support, or simply offer the .love alone for the other platforms.
    </section>
    <section name="Linux">
      On Linux, it's similar:
      [code]
      cat love game.love > game
      [/code]
      Then, you'll have to make a package for various packaging systems with dependencies
      as the love package. Were you to make a .deb package this way, for instance, the user would
      not have to install the love package separately.
      [br /][br /]
      Eventually, we will provide scripts which does this automatically for various
      package systems. You'll have to figure it out yourself until then.
    </section>
    <section name="Mac OS X">
      We do not have any Macs, so we can't provide binaries for this plaform yet. Why is this section even here?
      Just to remind everyone that we do intend to support Mac OS X in future.
    </section>
  </page>
  
  <module name="love.graphics">
    The graphics module is responsible for things like window management, Images, Animations,
    Fonts, and more.

    <type name="Image" brief="Represents a drawable image.">
      Images are created and drawn on screen using functions in love.graphics. Images do currently not exist in memory after they are created as GPU textures, thus methods
      for reading single pixel colors and similar are not available.[br /]
      [br /]Supported image formats:
      [ul]
      [li]PNG[/li]
      [li]BMP[/li]
      [li]GIF[/li]
      [li]JPEG[/li]
      [li]LBM[/li]
      [li]PCX[/li]
      [li]PNM[/li]
      [li]TGA[/li]
      [li]XCF[/li]
      [li]XPM[/li]
      [li]XV[/li]
      [li](And probably not TIFF)[/li]
      [/ul]
      <func name="getWidth" brief="Gets the width of an image.">
        <overload>
          <ret type="number" brief="The width of the image." />
        </overload>
      </func>
      <func name="getHeight" brief="Gets the height of an image.">
        <overload>
          <ret type="number" brief="The height of the image." />
        </overload>
      </func>
      <func name="setCenter" brief="Sets the center of the image.">
        <overload>
          <param name="x" />
          <param name="y" />
          For instance, a 128x64 image, will have a default center at [64,32] (the actual center). If you want the image to rotate around its top-left corner, you set the center to [0,0].
        </overload>
      </func>

      <see>
        love.graphics.newImage, Animation
      </see>

      <example id="1" />

    </type>

    <type name="Animation" brief="Represents a frame-by-frame animation.">
      Remember that Animations must be updated each frame. (See example)

      <func name="addFrame" brief="Adds a single frame to the Animation.">
        <overload>
          <param name="x" brief="The position of the frame along the x-axis." />
          <param name="y" brief="The position of the frame along the y-axis." />
          <param name="w" brief="The width of the frame." />
          <param name="h" brief="The height of the frame." />
          <param name="delay" brief="The delay in seconds after the frame. " />
        </overload>
      </func>

      <func name="setMode" brief="Sets the animation mode.">
        <overload>
          <param name="mode" brief="The animation mode." />
        </overload>
      </func>

      <func name="play" brief="Starts the Animation.">
        <overload></overload>
      </func>

      <func name="stop" brief="Stops the Animation">
        <overload></overload>
      </func>

      <func name="reset" brief="Sets the current frame to the first frame and resets timer." >
        <overload></overload>
      </func>

      <func name="seek" brief="Sets the current frame.">
        <overload>
          <param name="frame" brief="The frame number. (0 = first)" />
        </overload>
      </func>

      <func name="getCurrentFrame" brief="Gets the current frame number">
        <overload>
          <ret type="number" brief="The frame number, where 0 is the first frame."/>
        </overload>
      </func>

      <func name="getSize" brief="Gets the number of frames.">
        <overload>
          <ret type="number" brief="The number of frames." />
        </overload>
      </func>

      <func name="setDelay" brief="Sets the delay of a specific frame." >
        <overload>
          <param name="frame" brief="The frame number." />
          <param name="delay" brief="The new delay for the frame." />
        </overload>
      </func>

      <func name="setSpeed" brief="Sets the overall speed of the Animation.">
        <overload>
          <param name="speed" brief="Speed factor, where a value of 1 means normal speed." />
        </overload>
      </func>

      <func name="getSpeed" brief="Returns the current speed of the Animation.">
        <overload>
          <ret type="number" brief="The speed factor, where a value of 1 means normal speed." />
        </overload>
      </func>

      <func name="getWidth" brief="Gets the width of the current frame.">
        <overload>
          <ret type="number" brief="The width of the current frame in pixels." />
        </overload>
      </func>

      <func name="getHeight" brief="Gets the height of the current frame.">
        <overload>
          <ret type="number" brief="The height of the current frame in pixels." />
        </overload>
      </func>

      <func name="setCenter" brief="Changes the center of the Animation.">
        <overload>
          <param name="x" brief="The position of the center along the x-axis." />
          <param name="y" brief="The position of the center along the y-axis." />
          For instance, a 128x64 Animation (assuming all frames have equal size), will have a default center at (0,0)
          (the actual center). If you want the Animation to rotate around its top-left corner, you set the center to (-64,-32).
          Unlike Images, which have absolute centers, Animations have relative centers. This is because frames in an Animation
          can have variable dimensions.
        </overload>
      </func>

      <func name="update" brief="Updates the Animation">
        <overload>
          <param name="dt" brief="The time since last update." />
          Note that this must be called every frame for the Animation to run. See the example.
        </overload>
      </func>

      <see>
        love.graphics.newAnimation, Image
      </see>

      <example id="11" />

    </type>

    <type name="Font" brief="Represents a font.">

      <func name="getHeight" brief="Returns the height of the font.">
        <overload>
          <ret type="number" brief="The height of the font." />
          The height of the font is the size including any spacing; the height which it will need.
        </overload>
      </func>

      <func name="getWidth" brief="Returns the width of the line.">
        <overload>
          <param name="line" brief="A line of text." />
          <ret type="number" brief="The width of the font." />
          Determines the line width. Does not support line-breaks.
        </overload>
      </func>

      <func name="setLineHeight" brief="Sets the line height of the font.">
        <overload>
          <param name="height" brief="The new line height." />
          When rendering the font in lines the actual height will be determined by the line height multiplied by the height of the font. The default is 1.0
        </overload>
      </func>

      <func name="getLineHeight" brief="Returns the line height.">
        <overload>
          <ret type="number" brief="The line height." />
        </overload>
      </func>

      <see>
        love.graphics.newFont, love.graphics.newImageFont
      </see>

    </type>

    <type name="Color" brief="An object containing color information.">
      A Color object is created by calling any of the [b]love.graphics.newColor()[/b] functions.

      <func name="setRed" brief="Sets the amount of red in the color.">
        <overload>
          <param name="red" brief="The amount of red." />
        </overload>
      </func>

      <func name="setGreen" brief="Sets the amount of green in the color.">
        <overload>
          <param name="green" brief="The amount of green." />
        </overload>
      </func>

      <func name="setBlue" brief="Sets the amount of blue in the color.">
        <overload>
          <param name="blue" brief="The amount of blue." />
        </overload>
      </func>

      <func name="setAlpha" brief="Sets the amount of alpha in the color.">
        <overload>
          <param name="alpha" brief="The amount of alpha." />
        </overload>
      </func>

      <func name="getRed" brief="Gets the amount of red in the color.">
        <overload>
          <ret type="number" brief="The amount of red." />
        </overload>
      </func>

      <func name="getGreen" brief="Gets the amount of green in the color.">
        <overload>
          <ret type="number" brief="The amount of green." />
        </overload>
      </func>

      <func name="getBlue" brief="Gets the amount of blue in the color.">
        <overload>
          <ret type="number" brief="The amount of blue." />
        </overload>
      </func>

      <func name="getAlpha" brief="Gets the amount of alpha in the color.">
        <overload>
          <ret type="number" brief="The amount of alpha." />
        </overload>
      </func>

      <see>love.graphics.newColor</see>

    </type>

    <type name="ParticleSystem" brief="Contains information for a particle system.">
      The particle systems are created and drawn on the screen using functions in love.graphics. They also need to be updated in the update(dt) callback
      for you to see any changes in the particles emitted.

      <func name="setBufferSize" brief="Sets the size of the buffer (the max allowed amount of particles in the system).">
        <overload>
          <param name="size" brief="The buffer size." />
        </overload>
      </func>

      <func name="setSprite" space="true" brief="Sets the image which is to be emitted.">
        <overload>
          <param name="sprite" brief="An Image." />
        </overload>
      </func>

      <func name="setEmissionRate" brief="Sets the amount of particles emitted per second.">
        <overload>
          <param name="rate" brief="The amount of particles per second." />
        </overload>
      </func>

      <func name="setLifetime" brief="Sets how long the particle system should emit particles (if -1 then it emits particles forever).">
        <overload>
          <param name="life" brief="The lifetime of the emitter (in seconds)." />
        </overload>
      </func>

      <func name="setParticleLife" space="true" brief="Sets the life of the particles.">
        <overload>
          <param name="life" brief="The life of the particles (in seconds)." />
        </overload>
        <overload>
          <param name="min" brief="The minumum life of the particles (in seconds)." />
          <param name="max" brief="The maximum life of the particles (in seconds)." />
          Every particle created will have a lifetime between min and max.
        </overload>
      </func>

      <func name="setPosition" brief="Sets the position of the emitter.">
        <overload>
          <param name="x" brief="The x-coordinate." />
          <param name="y" brief="The y-coordinate." />
        </overload>
      </func>

      <func name="setDirection" brief="Sets the direction the particles will be emitted in (in degrees).">
        <overload>
          <param name="direction" brief="The direction of the particles (in degrees)." />
        </overload>
      </func>

      <func name="setSpread" space="true" brief="Sets the amount of spread for the system.">
        <overload>
          <param name="spread" brief="The amount of spread (degrees)." />
        </overload>
      </func>

      <func name="setSpeed" space="true" brief="Sets the speed of the particles.">
        <overload>
          <param name="speed" brief="The speed (in pixels per second)." />
        </overload>
        <overload>
          <param name="min" brief="The minimum speed (in pixels per second)." />
          <param name="max" brief="The maximum speed (in pixels per second)." />
          Every particle created will have a speed between min and max.
        </overload>
      </func>

      <func name="setGravity" brief="Sets the gravity affecting the particles (acceleration along the y-axis).">
        <overload>
          <param name="gravity" brief="The amount of gravity." />
        </overload>
        <overload>
          <param name="min" brief="The minimum gravity." />
          <param name="max" brief="The maximum gravity." />
          Every particle created will have a gravity between min and max.
        </overload>
      </func>

      <func name="setRadialAcceleration" brief="Sets the radial acceleration (acceleration towards the emitter).">
        <overload>
          <param name="acceleration" brief="The amount of acceleration." />
        </overload>
        <overload>
          <param name="min" brief="The minimum acceleration." />
          <param name="max" brief="The maximum acceleration." />
          Every particle created will have an acceleration between min and max.
        </overload>
      </func>

      <func name="setTangentialAcceleration" space="true" brief="Sets the tangential acceleration (acceleration perpendicular to the particle's direction).">
        <overload>
          <param name="acceleration" brie="The amount of acceleration." />
        </overload>
        <overload>
          <param name="min" brief="The minimum acceleration." />
          <param name="max" brief="The maximum acceleration." />
          Every particle created will have an acceleration between min and max.
        </overload>
      </func>

      <func name="setSize" brief="Sets the size of the image (1.0 being normal size).">
        <overload>
          <param name="size" brief="The size of the image." />
        </overload>
        <overload>
          <param name="start" brief="The size of the image upon creation." />
          <param name="end" brief="The size of the image upon death." />
          The particles will grow/shrink from the starting size to the ending size.
        </overload>
        <overload>
          <param name="start" brief="The size of the image upon creation." />
          <param name="end" brief="The size of the image upon death." />
          <param name="variation" brief="The degree of variation (0 meaning no variation and 1 meaning full variation between start and end)." />
          The particles will grow/shrink from the starting size to the ending size. The variation affects starting size only.
        </overload>
      </func>

      <func name="setSizeVariation" space="true" brief="Sets the degree of variation (0 meaning no variation and 1 meaning full variation between start and end).">
        <overload>
          <param name="variation" brief="The degree of variation." />
        </overload>
      </func>

      <func name="setRotation" brief="Sets the rotation of the image upon particle creation (in degrees).">
        <overload>
          <param name="rotation" brief="The rotation of the image (in degrees)." />
        </overload>
        <overload>
          <param name="min" brief="The minimum amount of rotation." />
          <param name="max" brief="The maximum amount of rotation." />
          Every particle created will have a rotation between min and max.
        </overload>
      </func>

      <func name="setSpin" brief="Sets the spin of the sprite.">
        <overload>
          <param name="size" brief="The amount of spin." />
        </overload>
        <overload>
          <param name="start" brief="The amount of spin upon creation." />
          <param name="end" brief="The amount of spin upon death." />
        </overload>
        <overload>
          <param name="start" brief="The amount of spin upon creation." />
          <param name="end" brief="The amount of spin upon death." />
          <param name="variation" brief="The degree of variation (0 meaning no variation and 1 meaning full variation between start and end)." />
        </overload>
      </func>

      <func name="setSpinVariation" space="true" brief="Sets the degree of variation (0 meaning no variation and 1 meaning full variation between start and end).">
        <overload>
          <param name="variation" brief="The degree of variation." />
        </overload>
      </func>

      <func name="setColor" space="true" brief="Sets the color of the image (color modulation needs to be activated for it to have any effect).">
        <overload>
          <param name="color" brief="A Color object." />
        </overload>
        <overload>
          <param name="start" brief="A Color object." />
          <param name="end" brief="A Color object." />
        </overload>
      </func>

      <func name="getX" brief="Gets the x-coordinate of the particle emitter's position.">
        <overload>
          <ret type="number" brief="The x-coordinate." />
        </overload>
      </func>

      <func name="getY" brief="Gets the y-coordinate of the particle emitter's position.">
        <overload>
          <ret type="number" brief="The y-coordinate." />
        </overload>
      </func>

      <func name="getDirection" brief="Gets the direction of the particle emitter (in degrees).">
        <overload>
          <ret type="number" brief="The direction." />
        </overload>
      </func>

      <func name="getSpread" space="true" brief="Gets the amount of directional spread of the particle emitter (in degrees).">
        <overload>
          <ret type="number" brief="The amount of spread." />
        </overload>
      </func>

      <func name="count" space="true" brief="Gets the amount of particles that are currently in the system.">
        <overload>
          <ret type="number" brief="The amount of particles." />
        </overload>
      </func>

      <func name="start" brief="Starts the particle emitter.">
        <overload></overload>
      </func>

      <func name="stop" brief="Stops the particle emitter, resetting the lifetime counter.">
        <overload></overload>
      </func>

      <func name="pause" brief="Pauses the particle emitter.">
        <overload></overload>
      </func>

      <func name="reset" space="true" brief="Resets the particle emitter, removing any existing particles and resetting the lifetime counter.">
        <overload></overload>
      </func>

      <func name="isActive" brief="Checks whether the particle system is actively emitting particles.">
        <overload>
          <ret type="boolean" brief="Whether the particle system is active." />
        </overload>
      </func>

      <func name="isEmpty" brief="Checks whether the particle system is empty of particles.">
        <overload>
          <ret type="boolean" brief="Whether the particle system is empty." />
        </overload>
      </func>

      <func name="isFull" space="true" brief="Checks whether the particle system is full of particles.">
        <overload>
          <ret type="boolean" brief="Whether the particle system is full." />
        </overload>
      </func>

      <func name="update" brief="Updates the particle system; moving, creating and killing particles.">
        <overload>
          <param name="dt" brief="The amount of time that has passed since last time the function was called." />
        </overload>
      </func>

      <see>love.graphics.newParticleSystem</see>

    </type>

    <func name="newImage" brief="Loads an image.">
      <overload brief="Creates an Image.">
        <param name="filename" brief="The filepath to the image file." />
        <ret type="Image" brief="An Image object containing the display data." />
      </overload>
      <overload brief="Creates an Image with a certain mode.">
        <param name="filename" brief="The filepath to the image file." />
        <param name="mode" brief="The type of image mode (padded, optimized, or both)." />
        <ret type="Image" brief="An Image object containing the display data." />
      </overload>
    </func>

    <func name="newAnimation" brief="Creates an Animation.">
      <overload>
        <param name="image" brief="The source Image for the Animation."/>
        <ret type="Animation" brief="An Animation object with no frames." />
      </overload>
      <overload>
        <param name="image" brief="The source Image for the Animation."/>
        <param name="fw" brief="The width of each frame."/>
        <param name="fh" brief="The height of each frame."/>
        <param name="delay" brief="The delay (seconds) between each frame."/>
        <param name="frames" brief="The number of frames to include. (0 = all)" />
        <ret type="Animation" />
        This method assumes that

        [ol]
        [li]The frames are all of equal size[/li]
        [li]The frames are ordered from top-left to bottom-right[/li]
        [li]The frame size fx*fh must also fit with the width and height of the source image.[/li]
        [/ol]
      </overload>
    </func>

    <func name="newColor" brief="Creates a color.">
      <overload>
        <param name="red" brief="The amount of red." />
        <param name="green" brief="The amount of green." />
        <param name="blue" brief="The amount of blue." />
        <param name="alpha" brief="The amount of alpha." />
        <ret type="Color" brief="A Color object containing the color data." />
      </overload>
      <overload>
        <param name="red" brief="The amount of red." />
        <param name="green" brief="The amount of green." />
        <param name="blue" brief="The amount of blue." />
        <ret type="Color" brief="A Color object containing the color data." />
      </overload>
    </func>

    <func name="newFont" brief="Creates a new font by loading the font file.">
      <overload brief="Creates a new Font with size 12.">
        <param name="filename" brief="The filepath to the font file." />
        <ret type="Font" brief="A Font object containing the font data." />
      </overload>
      <overload>
        <param name="filename" brief="The filepath to the font file." />
        <param name="size" brief="The size of the font." />
        <ret type="Font" brief="A Font object containing the font data." />
      </overload>
    </func>

    <func name="newImageFont" brief="Creates a new font by loading a specifically formatted image.">
      <overload>
        An image font is created by having a series of characters set next to each other in a horizontal row.
        Between all the characters and on the left and right sides should be a dividing line consisting of a single color
        (which is not found in the actual characters themselves).[br /]
        This [a href="gfx/imagefont.png"]example image[/a] is consiting of black and white glyphs on a transparent background
        where they are separated by yellow lines. The yellow will be used in determining where each character begins and ends.
        <param name="filename" brief="The filepath to the image file." />
        <param name="glyphs" brief="A list of the characters as they are in the image." />
        <ret type="Font" brief="A Font object containing the font data." />
      </overload>
      <overload>
        An image font is created by having a series of characters set next to each other in a horizontal row.
        Between all the characters and on the left and right sides should be a dividing line consisting of a single color
        (which is not found in the actual characters themselves).[br /]
        This [a href="gfx/imagefont.png"]example image[/a] is consiting of black and white glyphs on a pink background (background can be transparent)
        where they are separated by yellow lines. The yellow will be used in determining where each character begins and ends.[br /]
        <param name="filename" brief="The filepath to the image file." />
        <param name="glyphs" brief="A list of the characters as they are in the image." />
        <param name="spacing" brief="The spacing factor." />
        <ret type="Font" brief="A Font object containing the font data." />
      </overload>
    </func>

    <func name="newParticleSystem" brief="Creates a particle emitter." space="true">
      <overload>
        <param name="image" brief="An Image object." />
        <param name="buffer" brief="The maximum amount of particles that are allowed by the system." />
        <ret type="ParticleSystem" brief="A particle system containing the apporpriate information." />
      </overload>
    </func>

    <func name="checkMode" brief="Checks if a display mode is supported.">
      <overload>
      	This function checks whether a display mode is supported without changing
      	the display mode. You should always make sure that a mode is supported before trying to
      	set it with love.graphics.setMode.
        <param name="width" brief="Display width." />
        <param name="height" brief="Display height." />
        <param name="fullscreen" brief="Fullscreen (true), or windowed (false)." />
        <ret type="boolean" brief="True if supported, false otherwise" />
      </overload>
    </func>

    <func name="setMode" brief="Changes the display mode.">
      <overload>
        <param name="width" brief="Display width." />
        <param name="height" brief="Display height." />
        <param name="fullscreen" brief="Fullscreen (true), or windowed (false)." />
        <param name="vsync" brief="True if LOVE should wait for vsync, false otherwise (normally true)." />
        <param name="fsaa" brief="The number of FSAA-buffers (normally 0)." />
        <ret type="boolean" brief="True if successful, false otherwise" />
        <see>love.graphics.checkMode</see>

        Do not change the display mode unless you know that that mode is supported. Use love.graphics.checkMode to
        check whether a mode is supported or not. [br /]
        [br /]
        Also note that calling this function will cause the entire display context to reload. This
        means that all Images, Fonts and other graphical objects will have to be reloaded. It is
        therefore advisable to call this function when as few objects as possible has been loaded.

        [br /]
        [br /]
        FSAA stands for Full Scene Anti-Aliasing, and it is recommended to set this number to 0 (the default),
        unless you need anti-aliasing of the edges on primitves and images. Most machines which support this feature support
        1, 2 and 4 FSAA buffers. The more buffers, the better the anti-aliasing and the bigger the performance hit.
        Assuming you're not using filled primitives, you do not really need FSAA as long as you pad the sprites with some empty space; in this case FSAA will have no effect
        on the visuals at all, it will only hinder performance.
      </overload>
    </func>

    <func name="toggleFullscreen" brief="Toggles fullscreen.">
      <overload>
        <ret type="boolean" brief="True if successful" />
        The same goes for this method as for love.graphics.setMode: Do not change the display mode unless you know that that mode is supported. Use love.graphics.checkMode to
        check whether a mode is supported or not. [br /]
        [br /]
        Also note that calling this function will cause the entire display context to reload. This
        means that all Images, Fonts and other graphical objects will have to be reloaded. It is
        therefore advisable to call this function when as few objects as possible has been loaded.
      </overload>
    </func>

    <func name="isCreated" brief="Checks if the display has been set.">
      <overload>
        <ret type="boolean" brief="True if display has been set, false otherwise" />
        When configuring the display manually, it is useful to know if the display
        has been created. This way, we can avoid unnecessary display changes when
        the game reloads. The example below should make it more clear.[br /]
        [br /]
        Note that the configuration option display_auto must be set to false to
        use manual configuration of the display.
      </overload>
    </func>

    <func name="getModes" brief="Gets a list of supported fullscreen modes.">
      <overload>
        <ret type="table" name="modes"  brief="A table of width/height pairs." />
        This function does not include windowed modes, because they are generally supported with
        any screen resolution. To see the exact nature of the returned table, see example below.
        <example id="104" />     
     </overload>
    </func>

    <func name="setCaption" brief="Sets the window caption." space="true">
      <overload>
      	You can also set the caption with the "title" attribute in the config file.
        <param name="caption" brief="The new window caption." />
      </overload>
    </func>

    <func name="setColor" brief="Sets the current color.">
      <overload>
        <param name="color" brief="A Color object." />
      </overload>
      <overload>
        <param name="red" brief="The amount of red." />
        <param name="green" brief="The amount of green." />
        <param name="blue" brief="The amount of blue." />
      </overload>
      <overload>
        <param name="red" brief="The amount of red." />
        <param name="green" brief="The amount of green." />
        <param name="blue" brief="The amount of blue." />
        <param name="alpha" brief="The amount of alpha." />
      </overload>
    </func>

    <func name="setBackgroundColor" brief="Sets the background color.">
      <overload>
        [b]Note:[/b] The alpha value of the Color will be ignored as the background cannot be transparent.
        <param name="color" brief="A Color object." />
      </overload>
      <overload>
        <param name="red" brief="The amount of red." />
        <param name="green" brief="The amount of green." />
        <param name="blue" brief="The amount of blue." />
      </overload>
    </func>

    <func name="setFont" brief="Sets the current font." space="true">
      <overload>
        <param name="font" brief="A Font object." />
      </overload>
      <overload brief="Loads a font, and sets it as current.">
        <param name="filename" brief="Filepath to a Font file." />
      </overload>
      <overload brief="Loads a font, and sets it as current.">
        <param name="filename" brief="Filepath to a Font file." />
        <param name="size" brief="The size of the Font." />
      </overload>
    </func>

    <func name="setLineWidth" brief="Sets the line width.">
      <overload>
        <param name="width" brief="The width of the line." />
      </overload>
    </func>

    <func name="setLineStyle" brief="Sets line anti-aliasing.">
      <overload>
        Possible line styles are love.line_smooth and love.line_rough.
        <param name="style" brief="Line style." />
      </overload>
    </func>

    <func name="setLine" brief="Sets the width of the line used when drawing outlined primitives.">
      <overload>
        <param name="width" brief="The width of the line." />
      </overload>
      <overload>
        <param name="width" brief="The width of the line." />
        <param name="type" brief="The type of line (smooth/rough)." />
      </overload>
    </func>
    <func name="setLineStipple" brief="Sets a line stipple pattern.">
      <overload brief="Disables line stipple.">
      </overload>
      <overload brief="Sets a new stipple pattern.">
        <param name="pattern" brief="A 16-bit pattern." />
      </overload>
      <overload brief="Sets a new stipple pattern.">
        <param name="pattern" brief="A 16-bit pattern." />
        <param name="repeat" brief="Repeat factor." />
      </overload>
    </func>

    <func name="getLineWidth" brief="Gets the current line width.">
      <overload>
        <ret type="number" brief="The current line width." />
      </overload>
    </func>

    <func name="getLineStyle" brief="Gets the current line style.">
      <overload>
        <ret name="number" brief="love.line_smooth or love.line_rough." />
      </overload>
    </func>

    <func name="getLineStipple" brief="Gets the current stipple pattern." space="true">
      <overload>
        <ret type="number" name="pattern" brief="A 16-bit pattern." />
        <ret type="number" name="rep" brief="Repeat factor." />
      </overload>
    </func>

    <func name="setPointSize" brief="Sets the point size.">
      <overload>
        <param name="size" brie="The new point size." />
      </overload>
    </func>

    <func name="setPointStyle" brief="Sets the point style.">
      <overload>
        <param name="style" brief="The point style (love.point_smooth/rough)." />
      </overload>
    </func>

    <func name="setPoint" brief="Sets the point size and style.">
      <overload>
        <param name="size" brief="The point size." />
        <param name="style" brief="The point style (love.point_smooth/rough)." />
      </overload>
    </func>

    <func name="getPointSize" brief="Gets the current point size.">
      <overload>
        <ret type="number" name="size" brief="The point size." />
      </overload>
    </func>

    <func name="getPointStyle" brief="Gets the current point style.">
      <overload>
        <ret type="number" name="style" brief="The point style (love.point_smooth/rough)." />
      </overload>
    </func>

    <func name="getMaxPointSize" brief="Gets the max supported point size." space="true">
      <overload>
        <ret type="number" name="max" brief="The max supported size." />
      </overload>
    </func>

    <func name="setBlendMode" brief="Sets the blending mode.">
      <overload>
        The blending mode controls the way transparent elements blend together.
        <param name="mode" brief="The blending mode." />
      </overload>
    </func>

    <func name="setColorMode" brief="Sets the color mode.">
      <overload>
        The color mode controls how the current color affects elements.
        <param name="mode" brief="The color mode." />
      </overload>
    </func>

    <func name="getBlendMode" brief="Gets the current blend mode.">
      <overload>
        <ret type="number" brief="And int representing the current blend mode." />
      </overload>
    </func>

    <func name="getColorMode" brief="Gets the current color mode." space="true">
      <overload>
        <ret type="number" brief="And int representing the current color mode." />
      </overload>
    </func>

    <func name="getColor" brief="Gets the current color.">
      <overload>
        <ret type="Color" brief="The current color." />
      </overload>
    </func>

    <func name="getBackgroundColor" brief="Gets the current background color.">
      <overload>
        <ret type="Color" brief="The current background color." />
      </overload>
    </func>

    <func name="getFont" brief="Gets the current font." space="true">
      <overload>
        <ret type="Font" brief="The current font." />
      </overload>
    </func>

    <func name="getWidth" brief="Gets the width of the window.">
      <overload>
        <ret type="number" brief="The width of the game window." />
      </overload>
    </func>

    <func name="getHeight" brief="Gets the height of the window." space="true">
      <overload>
        <ret type="number" brief="The height of the game window." />
      </overload>
    </func>

    <func name="setScissor" brief="Scissor defines a box such that everything outside that box is discared and not drawn.">
      <overload>
        <param name="x" brief="The x-coordinate of the scissor box." />
        <param name="y" brief="The y-coordinate of the scissor box." />
        <param name="width" brief="The width of the scissor box." />
        <param name="height" brief="The height of the scissor box." />
      </overload>
      <overload brief="Clears the scissor area.">
      </overload>
    </func>

    <func name="getScissor" brief="Gets the current scissor box." space="true">
      <overload>
        <ret name="x" type="number" brief="The x-coordinate of the scissor box." />
        <ret name="y" type="number" brief="The y-coordinate of the scissor box." />
        <ret name="w" type="number" brief="The width of the scissor box." />
        <ret name="h" type="number" brief="The height of the scissor box." />
      </overload>
    </func>

    <func name="draw" brief="Draws." space="true">
      <overload brief="Draws text on screen.">
        Draws text in the current color.
        <param name="string" brief="A text string." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
      </overload>
      <overload brief="Draws rotated text on screen.">
        Draws rotated text in the current color.
        <param name="string" brief="A text string." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
      </overload>
      <overload brief="Draws rotated/scaled text on screen.">
        Draws rotated text in the current color.
        <param name="string" brief="A text string." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="s" brief="The scale factor." />
      </overload>
      <overload brief="Draws rotated/scaled text on screen.">
        Draws rotated text in the current color.
        <param name="string" brief="A text string." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="sx" brief="The scale factor along the x-axis." />
        <param name="sy" brief="The scale factor along the y-axis." />
      </overload>
      <overload brief="Draws an Image or Animation on screen.">
        <param name="sprite" brief="An Image or Animation object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
      </overload>
      <overload brief="Draws a rotated Image or Animation on screen.">
        <param name="sprite" brief="An Image or Animation object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
      </overload>
      <overload brief="Draws a rotated/scaled Image or Animation on screen.">
        <param name="sprite" brief="An Image or Animation object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="s" brief="The scale factor." />
      </overload>
      <overload brief="Draws a rotated/scaled Image or Animation on screen.">
        <param name="sprite" brief="An Image or Animation object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="sx" brief="The scale factor along the x-axis." />
        <param name="sy" brief="The scale factor along the y-axis." />
      </overload>
      <overload brief="Draws a particle system on screen.">
        <param name="particlesystem" brief="A ParticleSystem object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
      </overload>
    </func>

    <func name="drawf" brief="Draws formatted text on screen, with word wrap." space="true">
      <overload>
        Draws text in the current color, with word wrap.
        <param name="string" brief="A text string." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="limit" brief="Wrap the line after this many horizontal pixels." />
      </overload>
      <overload>
        Draws text in the current color, with word wrap and alignment.
        <param name="string" brief="A text string." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="limit" brief="Wrap the line after this many horizontal pixels." />
        <param name="align" brief="The alignment" />
      </overload>
    </func>

    <func name="draws" brief="Draws a subsprite of an Image." space="true">
      <overload brief="Draws a subsprite of an Image.">
        <param name="image" brief="An Image object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="cx" brief="The x-position of the image section (top-left)." />
        <param name="cy" brief="The y-position of the image section (top-left)." />
        <param name="w" brief="The width of the image section." />
        <param name="h" brief="The height of the image section." />
      </overload>
      <overload brief="Draws a rotated subsprite of an Image.">
        <param name="image" brief="An Image object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="cx" brief="The x-position of the image section (top-left)." />
        <param name="cy" brief="The y-position of the image section (top-left)." />
        <param name="w" brief="The width of the image section." />
        <param name="h" brief="The height of the image section." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
      </overload>
      <overload brief="Draws a rotated/scaled subsprite of an Image.">
        <param name="image" brief="An Image object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="cx" brief="The x-position of the image section (top-left)." />
        <param name="cy" brief="The y-position of the image section (top-left)." />
        <param name="w" brief="The width of the image section." />
        <param name="h" brief="The height of the image section." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="s" brief="The scale factor." />
      </overload>
      <overload brief="Draws a rotated/scaled subsprite of an Image.">
        <param name="image" brief="An Image object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="cx" brief="The x-position of the image section (top-left)." />
        <param name="cy" brief="The y-position of the image section (top-left)." />
        <param name="w" brief="The width of the image section." />
        <param name="h" brief="The height of the image section." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="sx" brief="The scale factor along the x-axis." />
        <param name="sy" brief="The scale factor along the y-axis." />
      </overload>
      <overload brief="Draws a rotated/scaled subsprite of an Image, rotating around a different center.">
        <param name="image" brief="An Image object." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="cx" brief="The x-position of the image section (top-left)." />
        <param name="cy" brief="The y-position of the image section (top-left)." />
        <param name="w" brief="The width of the image section." />
        <param name="h" brief="The height of the image section." />
        <param name="angle" brief="The angle of rotation (in degrees)." />
        <param name="sx" brief="The scale factor along the x-axis." />
        <param name="sy" brief="The scale factor along the y-axis." />
        <param name="ox" brief="The x-coordinate of the center." />
        <param name="oy" brief="The y-coordinate of the center." />
      </overload>
    </func>

    <func name="point" brief="Draws a point at (x,y).">
      <overload>
        <param name="x" brief="Position along x-axis." />
        <param name="y" brief="Position along y-axis." />
      </overload>
    </func>

    <func name="line" brief="Draws a line from (x1,y1) to (x2,y2).">
      <overload>
        <param name="x1" brief="First x-coordinate." />
        <param name="y1" brief="First y-coordinate." />
        <param name="x2" brief="Second x-coordinate." />
        <param name="y2" brief="Second y-coordinate." />
      </overload>
    </func>

    <func name="triangle" brief="Draws a triangle usign the passed coordinates.">
      <overload>
        [b]Note:[/b] When drawing a filled triangle, the coordinates must be passed in a counter-clockwise order.
        <param name="type" brief="The type of triangle (outline/filled)." />
        <param name="x1" brief="First x-coordinate." />
        <param name="y1" brief="First y-coordinate." />
        <param name="x2" brief="Second x-coordinate." />
        <param name="y2" brief="Second y-coordinate." />
        <param name="x3" brief="Third x-coordinate." />
        <param name="y3" brief="Third y-coordinate." />
      </overload>
    </func>

    <func name="rectangle" brief="Draws a rectangle.">
      <overload>
        <param name="type" brief="The type of rectangle (outline/filled)." />
        <param name="x" brief="X-coordinate of top-left corner." />
        <param name="y" brief="Y-coordinate of top-left corder." />
        <param name="w" brief="Width of the rectangle." />
        <param name="h" brief="Height of the rectangle." />
      </overload>
    </func>

    <func name="quad" brief="Draws a quadrilateral usign the passed coordinates.">
      <overload>
        [b]Note:[/b] When drawing a filled quadrilateral, the coordinates must be passed in a counter-clockwise order.
        <param name="type" brief="The type of quad (outline/filled)." />
        <param name="x1" brief="First x-coordinate." />
        <param name="y1" brief="First y-coordinate." />
        <param name="x2" brief="Second x-coordinate." />
        <param name="y2" brief="Second y-coordinate." />
        <param name="x3" brief="Third x-coordinate." />
        <param name="y3" brief="Third y-coordinate." />
        <param name="x4" brief="Fourth x-coordinate." />
        <param name="y4" brief="Fourht y-coordinate." />
      </overload>
    </func>

    <func name="circle" brief="Draws a circle usign the passed information.">
      <overload>
        <param name="type" brief="The type of circle (outline/filled)." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="radius" brief="Radius of the circle." />
      </overload>
      <overload>
        <param name="type" brief="The type of circle (outline/filled)." />
        <param name="x" brief="The position on the x-axis." />
        <param name="y" brief="The position on the y-axis." />
        <param name="radius" brief="Radius of the circle." />
        <param name="points" brief="The amount of points to use to draw the circle." />
      </overload>
    </func>

    <func name="polygon" brief="Draws a polygon." space="true">
      <overload>
        <param name="type" brief="The type of polygon. (outline/filled)." />
        <param name="..." brief="The vertices of the polygon" />
      </overload>
    </func>

    <func name="screenshot" brief="Save a screenshot as BMP.">
      <overload>
        The file will be stored in the save folder (see love.filesystem).
        Support for additional formats will be added later. 
        <param name="filename" brief="The filename of the screenshot." />
        <see>love.filesystem</see>
      </overload>
    </func>

    <example id="1" />
  </module>
  <module name="love.audio">

    The audio module is currently a wrapper around SDL_mixer, and has very limited
    features as of yet.

    <type name="Sound" brief="A sound effect.">
      Can load the following formats: WAVE, OGG, AIFF, RIFF and VOC. Sound is fully
      expanded into memory when the game loads. This means that if you load a
      5MB compressed .ogg file as a sound, it would consume ~50MB RAM when fully
      decompressed. Consider using Music in such cases.[br /]
      [br /]
      Note that the Sound object does not contain funcs to play itself back;
      love.audio.play must be used for this.
      <func name="setVolume" brief="Sets the volume the sound should be played at.">
        <overload>
          <param name="volume" brief="The volume (a number between 0 and 1.0)." />
        </overload>
      </func>
    </type>
    <type name="Music" brief="Streaming sound.">
      Can load the following formats: MP3, OGG, MIDI, XM, MOD,
      and a variety of other tracker formats.

      Music, unlike Sound, isn't fully decoded and expanded into
      memory when the game loads; decoding takes place during run-time.[br /]
      [br /]
      Note that the Music object itself has no funcs; it is currently only used as a handle. To play Music,
      use love.audio.play.
      <see>
        Sound, love.audio, love.audio.newMusic
      </see>
    </type>

    <func name="newSound" brief="Loads a sound file.">
      <overload>
        <param name="filename" brief="The filepath to the sound file." />
        <ret type="Sound" brief="A Sound object containing the audio data." />
      </overload>
    </func>

    <func name="newMusic" brief="Loads a music file." space="true">
      <overload>
        <param name="filename" brief="The filepath to the music file." />
        <ret type="Music" brief="A Music object containing the audio data." />
      </overload>
    </func>

    <func name="play" brief="Plays a sound." space="true">
      <overload>
        <param name="sound" brief="The sound to play." />
        The Sound is played a single time, on the first available channel.
      </overload>
      <overload space="true">
        <param name="sound" brief="The sound to play." />
        <param name="loop" brief="The number of times to loop. (1 = play once, 0 = forever)." />
      </overload>
      <overload>
        <param name="music" brief="The Music object to play." />
        Remember that only one Music can play at any time. (See love.audio).
      </overload>
      <overload>
        <param name="music" brief="The Music object to play." />
        <param name="loop" brief="The number of times to loop. (1 = play once, 0 = forever)." />
        Remember that only one Music can play at any time. (See love.audio).
      </overload>
    </func>

    <func name="pause" brief="Pauses all audio playback.">
      <overload>

      </overload>
    </func>

    <func name="resume" brief="Resumes all audio playback.">
      <overload>
      </overload>
    </func>

    <func name="stop" brief="Stops all audio playback."  space="true">
      <overload>
      </overload>
    </func>

    <func name="isPlaying" brief="Checks whether (any) audio is playing or not.">
      <overload>
        <ret type="boolean" brief="True if audio is playing, false otherwise" />
      </overload>
    </func>

    <func name="isPaused" brief="Checks whether audio playback is paused or not." space="true">
      <overload>
        <ret type="boolean" brief="True if audio is paused, false otherwise." />
      </overload>
    </func>

    <func name="setChannels" brief="Sets the amount of channels for sounds.">
      <overload>
        <param name="channels" brief="A number. Any number below 0 will have no effect." />
      </overload>
    </func>

    <func name="setMode" brief="Sets the mode for audio mixing and playback." space="true">
      <overload>
        <param name="frequency" brief="The amount of Hz to use." />
        <param name="mode" brief="The audio mode (1 = mono, 2 = stereo)." />
        <param name="buffersize" brief="The size of the buffer (bits per output per sample)." />
      </overload>
    </func>

    <func name="setVolume" brief="Changes the master volume.">
      <overload>
        <param name="volume" brief="A number between 0 (min) and 1 (max)." />
      </overload>
    </func>

  </module>
  <module name="love.physics">

    The physics module is capable of deteting collisions between objects, and simulate
    a realistic responses.[br /]
    [br /]
    The module is currently based on [a href="http://www.box2d.org/"]Box2D[/a]. The original
    naming scheme is kept, and most of the functionality avaliable in Box2D is avaliable in LÖVE,
    so you can also take a look at the
    [a href="http://www.box2d.org/manual.html"]Box2D User Manual[/a] for detailed
    documentation.[br /]
    [br /]
    Some limitations to keep in mind:
    [ul]
    [li]Only convex shapes are supported.[/li]
    [li]The max vertex count for on a single polygon is 8.[/li]
    [li]There are 16 shape categories.[/li]
    [/ul]

    <example id="100" />

    <type name="World" brief="Contains all Bodies and joints.">
      A World is a container object for the bodies and joints. It also represents the actual space
      the objects reside in, eg. the World has size and gravity properties.[br /]
      [br /]
      You can use several Worlds, but only objects in the same World can interact with eachother.
      <func name="update" brief="Updates the state of the objects in the World." space="true">
        <overload>
          When this function is called, the physics simulation is run according to the specified 
          timestep.
          <param name="dt" brief="The time since last frame." />
          <example id="100" />
        </overload>
      </func>
      <func name="setGravity" brief="Sets the gravity.">
        <overload>
          <param name="x" brief="The x-component of the gravity vector." />
          <param name="y" brief="The y-component of the gravity vector." />
        </overload>
      </func>
      <func name="getGravity" brief="Gets the gravity." space="true">
        <overload>
          <ret type="number" name="x" brief="The x-component of the gravity vector." />
          <ret type="number" name="y" brief="The y-component of the gravity vector." />
        </overload>
      </func>

      <func name="setCallback" brief="Sets the collision callback.">
        <overload>
          The callback (if any) will be called every time contact is made between two shapes in the World. 
          The Lua function should accept three parameters: shapedata1, shapedata2 and a Contact object.
          <param name="f" brief="A Lua function." />
          <example id="101" />
        </overload>
      </func>

      <func name="getCallback" brief="Gets the collision callback." space="true">
        <overload>
          Gets the function set with World:setCallback. If no function is set, nil will be 
          returned.
          <ret type="function" name="f" brief="The current callback function, or nil if none." />
        </overload>
      </func>

      <func name="getBodyCount" brief="Gets the number of Bodies in the World.">
        <overload>
          <ret name="num" type="number" brief="The number of Bodies."/>
        </overload>
      </func>
      <func name="getJointCount" brief="Gets the number of joints in the World.">
        <overload>
          <ret name="num" type="number" brief="The number of joints."/>
        </overload>
      </func>
    </type>

    <type name="Contact" brief="Represents a contact point between two shapes.">

      This objects contains information about the a contact point between two Shapes.
      
      <example id="102" />
      
      <func name="getFriction" brief="Gets the mixed friction between the two shapes.">
        <overload>
          <example id="102" />
          <ret name="friction" type="number" brief="The mixed friction" />
        </overload>
      </func>
      <func name="getRestitution" brief="Gets the mixed restitution between the two shapes." space="true">
        <overload>
          <example id="102" />
          <ret name="restitution" type="number" brief="The mixed restitution" />
        </overload>
      </func>

      <func name="getSeparation" brief="Gets the separation of the two shapes.">
        <overload>
          <example id="102" />
          <ret name="separation" brief="The separation. Negative if overlapping." />
        </overload>
      </func>
      <func name="getPosition" brief="Gets the position of the Contact point.">
        <overload>
          <example id="102" />
          <ret name="x" type="number" brief="The x-component of the point." />
          <ret name="y" type="number" brief="The y-component of the point." />
        </overload>
      </func>
      <func name="getVelocity" brief="Gets the velocity at the Contact point.">
        <overload>
          <example id="102" />
          <ret name="x" type="number" brief="The x-component of the velocity." />
          <ret name="y" type="number" brief="The y-component of the velocity." />
        </overload>
      </func>
      <func name="getNormal" brief="Gets the Contact normal.">
        <overload>
          <example id="102" />
          <ret name="x" type="number" brief="The x-component of the normal." />
          <ret name="y" type="number" brief="The y-component of the normal." />
        </overload>
      </func>

    </type>

    <type name="Body" plural="Bodies" brief="A Body is a physical entity with position and orientation." space="true">

      It's important to understand the difference between shapes and bodies. A Body has a position and 
      orientation in the World cooridnate system, whereas shapes are attatched to a Body. Shapes simply
      act as the collision geometry of the Body. Why bother differentiating betwen the two? Because it allows
      us to create advanced Bodies composed of many shapes.[br /]
      [br /]
      It is worth noting that shapes collide, but Bodies don't. This means that even if you attatch several shapes
      to a single Body (for instance a gradually destructible "boss"), you'll easily be able to detect which parts
      collide with what.
      
      <func name="getX" brief="Gets the x-component of the position.">
        <overload>
        	This function gets only the x-component, which may be useful in rare cases. Normally though, 
        	you would want to get both x- and y-components, in which case Body:getPosition is more
        	appropriate.
          <ret name="x" type="number" brief="The x-component of the position." />
          <see>Body:getPosition</see>
        </overload>
      </func>
      <func name="getY" brief="Gets the y-component of the position.">
        <overload>
        	This function gets only the y-component, which may be useful in rare cases. Normally though,
        	you would want to get both x- and y-components, in which case Body:getPosition is more
        	appropriate.
          <ret name="y" type="number" brief="The y-component of the position." />
          <see>Body:getPosition</see>
        </overload>
      </func>
      <func name="getPosition" brief="Gets the position of the Body.">
        <overload>
        	Gets the position of the Body in world coordinates. Note that the position not necessarily is
			the same as the Body's center of mass.
          <ret name="x" type="number" brief="The x-component of the position." />
          <ret name="y" type="number" brief="The y-component of the position." />
          <see>Body:getWorldCenter</see>
        </overload>
      </func>
      <func name="getVelocity" brief="Gets the velocity of the Body." space="true">
        <overload>
        Gets the linear velocity of the Body at the center of mass.
          <ret name="x" type="number" brief="The x-component of the velocity." />
          <ret name="y" type="number" brief="The y-component of the velocity." />
          <see>Body:getSpin</see>
        </overload>
      </func>

      <func name="getAngle" brief="Gets the current angle of the Body.">
        <overload>
        	Gets the angle of the Body in degrees. This is useful when you want
        	to draw a rotated image to match the Body's angular movements.
          <ret name="angle" type="number" brief="The angle in degrees." />
        </overload>
      </func>
      <func name="getSpin" brief="Gets the current spin of the Body." space="true">
        <overload>
        	The spin is the angular velocity, measured in degrees per second.
          <ret name="angle" type="number" brief="The spin in degrees/second." />
        </overload>
      </func>

      <func name="getMass" brief="Gets the mass of Body.">
        <overload>
          <ret name="mass" type="number" brief="The mass of the Body." />
        </overload>
      </func>
      <func name="getInertia" brief="Gets the inertia of Body." space="true">
        <overload>
          <ret name="inertia" type="number" brief="The inertia of the Body." />
        </overload>
      </func>

      <func name="getDamping" brief="Gets linear damping.">
        <overload>
          <ret name="damping" type="number" brief="The linear damping" />
        </overload>
      </func>

      <func name="getAngularDamping" brief="Gets angular damping." space="true">
        <overload>
          <ret name="damping" type="number" brief="The angular damping" />
        </overload>
      </func>

      <func name="getWorldCenter" brief="Gets the center of mass in world coordinates.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the world point." />
          <ret name="y" type="number" brief="The y-component of the world point." />
        </overload>
      </func>
      <func name="getLocalCenter" brief="Gets the center of mass in local coordinates.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the local point." />
          <ret name="y" type="number" brief="The y-component of the local point." />
        </overload>
      </func>

      <func name="getWorldPoint" brief="Transforms a point from local coordinates to world coordinates.">
        <overload>
          <param name="x" brief="The x-component of the local point." />
          <param name="y" brief="The y-component of the local point." />
          <ret name="x" type="number" brief="The x-component of the world point." />
          <ret name="y" type="number" brief="The y-component of the world point." />
        </overload>
      </func>
      <func name="getWorldVector" brief="Transforms a vector from local coordinates to world coordinates.">
        <overload>
          <param name="x" brief="The x-component of the local vector." />
          <param name="y" brief="The y-component of the local vector." />
          <ret name="x" type="number" brief="The x-component of the world vector." />
          <ret name="y" type="number" brief="The y-component of the world vector." />
        </overload>
      </func>
      <func name="getLocalPoint" brief="Transforms a point from world coordinates to local coordinates.">
        <overload>
          <param name="x" brief="The x-component of the world point." />
          <param name="y" brief="The y-component of the world point." />
          <ret name="x" type="number" brief="The x-component of the local point." />
          <ret name="y" type="number" brief="The y-component of the local point." />
        </overload>
      </func>
      <func name="getLocalVector" brief="Transforms a vector from world coordinates to local coordinates.">
        <overload>
          <param name="x" brief="The x-component of the world vector." />
          <param name="y" brief="The y-component of the world vector." />
          <ret name="x" type="number" brief="The x-component of the local vector." />
          <ret name="y" type="number" brief="The y-component of the local vector." />
        </overload>
      </func>
      <func name="getVelocityWorldPoint" brief="Gets the velocity on the Body for the given world point.">
        <overload>
          <param name="x" brief="The x-component of the world point." />
          <param name="y" brief="The y-component of the world point." />
          <ret name="x" type="number" brief="The x-component of the velocity vector." />
          <ret name="x" type="number" brief="The x-component of the velocity vector." />
        </overload>
      </func>
      <func name="getVelocityLocalPoint" brief="Gets the velocity on the Body for the given local point." space="true">
        <overload>
          <param name="x" brief="The x-component of the local point." />
          <param name="y" brief="The y-component of the local point." />
          <ret name="x" type="number" brief="The x-component of the velocity vector." />
          <ret name="x" type="number" brief="The x-component of the velocity vector." />
        </overload>
      </func>

      <func name="applyImpulse" brief="Applies an impulse to the Body.">
        <overload>
          <param name="jx" brief="The x-component of the impulse." />
          <param name="jy" brief="The y-component of the impulse." />
        </overload>
        <overload brief="Applies an impulse to the Body with an offset.">
          <param name="jx" brief="The x-component of the impulse." />
          <param name="jy" brief="The y-component of the impulse." />
          <param name="rx" brief="The x-component of the offset." />
          <param name="ry" brief="The y-component of the offset." />
        </overload>
      </func>
      <func name="applyForce" brief="Applies force to the Body.">
        <overload>
          <param name="fx" brief="The x-component of the force." />
          <param name="fy" brief="The y-component of the force." />
        </overload>
        <overload brief="Applies force to the Body with an offset.">
          <param name="fx" brief="The x-component of the force." />
          <param name="fy" brief="The y-component of the force." />
          <param name="rx" brief="The x-component of the offset." />
          <param name="ry" brief="The y-component of the offset." />
        </overload>
      </func>
      <func name="applyTorque" brief="Applies torque to the Body." space="true">
        <overload>
          <param name="t" brief="The torque to apply to the Body." />
        </overload>
      </func>





      <func name="setX" brief="Sets the x-component of the position.">
        <overload>
        	In rare cases, you might want to set just the x-component of a Body, but when
        	you need to set both components, you should use Body:setPosition.
          <param name="x" brief="The new x-component." />
          <see>Body:setPosition</see>
        </overload>
      </func>
      <func name="setY" brief="Sets the y-component of the position.">
        <overload>
            In rare cases, you might want to set just the y-component of a Body, but when
        	you need to set both components, you should use Body:setPosition.
          <param name="y" brief="The new y-component." />
          <see>Body:setPosition</see>
        </overload>
      </func>
      <func name="setPosition" brief="Sets the position of the Body.">
        <overload>
        	Note that setting the position directly is not a great way to move Bodies. This function
        	should only be used for initial placement of Bodies, or when stuff needs to "warp" from one
        	place to another. When you want Bodies to move, and not warp, use Body:applyImpulse
			or Body:setVelocity.[br /]
			[br /]Also note that it is very possible to move Bodies into a collision state with
        	another Body. This does not have catastrophic consequences, but a number of simulation cycles will
        	be required to move the Bodies out of the collison state.
          <param name="x" brief="The x-component of the position." />
          <param name="y" brief="The y-component of the position." />
          <see>Body:applyImpulse, Body:setVelocity</see>
        </overload>
      </func>
      <func name="setVelocity" brief="Sets the velocity of the Body." space="true">
        <overload>
        	Sets a new linear velocity for the Body. This function will not accumulate anything; 
        	any impulses previously applied since the last call to World:update will be lost.
          <param name="x" brief="The x-component." />
          <param name="y" brief="The y-component." />
        </overload>
      </func>
      <func name="setAngle" brief="Sets the angle of the Body.">
        <overload>
        	Sets the current angle of the Body directly. Like Body:setPosition, it is possible to turn a Body 
        	into a collision state with another Body.
          <param name="angle" brief="The angle in degrees." />
        </overload>
      </func>
      <func name="setSpin" brief="Sets the spin of the Body." space="true">
        <overload>
        	Sets the angular velocity of the Body (how fast it should rotate).
          <param name="spin" brief="The spin in degrees/second" />
        </overload>
      </func>

      <func name="setMassFromShapes" brief="Sets mass properties from attatched shapes.">
        <overload>
        	If you feel that finding the correct mass properties is tricky, then this function
        	may be able to help you. After creating the needed shapes on the Body, a call to
        	this function will set the mass properties based on those shapes. Remember to call
        	this function [i]after[/i] adding the shapes.[br /]
        	[br /]
        	Setting the mass properties this way always results in a realistic (or at least good-looking)
        	simulation, so using it is highly recommended.
        </overload>
      </func>
      <func name="setMass" brief="Sets mass properies directly." space="true">
        <overload brief="Sets mass properies directly.">
        	Sets the mass properties directly. If you're not sure what all this stuff means, you
        	can use Body:setMassFromShapes after adding shapes instead.
          <param name="x" brief="The x-component of the center of mass in local coordinates." />
          <param name="y" brief="The y-component of the center of mass in local coordinates." />
          <param name="m" brief="The mass." />
          <param name="i" brief="The inertia." />
        </overload>
      </func>

      <func name="setDamping" brief="Sets the linear damping of the Body.">
        <overload>
          <param name="damping" brief="The linear damping of the Body." />
        </overload>
      </func>

      <func name="setAngularDamping" brief="Sets the angular damping of the Body." space="true">
        <overload>
          <param name="damping" brief="The angular damping of the Body." />
        </overload>
      </func>

      <func name="isBullet" brief="Checks whether this Body should be treated as a bullet.">
        <overload>
        	<see>CircleShape:setBullet</see>
        </overload>
      </func>

      <func name="setBullet" brief="Sets whether this Body should be treated as a Bullet." space="true">
        <overload>
        	Normal Bodies will be able to pass through other Bodies if they move at sufficient speed, unless they
        	are treated as bullets. When a Body is treated as a bullet, continuous collision detection is performed, 
        	which means that even collision between frames are detected.[br /]
        	[br /]
        	The drawback of using this method is additional (and significant) computational complexity. Only set
        	Bodies as bullets if you expect them to move really fast.
          <param name="bullet" brief="True for bullet, false for normal." />
        </overload>
      </func>

      <func name="isStatic" brief="Checks whether this Body is static.">
        <overload>
		A static Body is one that can't be moved, i.e. "terrain".
		</overload>
      </func>

      <func name="isDynamic" brief="Checks whether this Body is dynamic.">
        <overload>
		A dynamic Body is one that isn't static.
		<see>Body:isStatic</see>
		</overload>
      </func>

      <func name="isFrozen" brief="Checks whether this Body is frozen.">
        <overload>
		When a Body hits the Word boundary, it freezes. This function checks if
		a Body is in that state.
		</overload>
      </func>

      <func name="isSleeping" brief="Checks whether this Body is sleeping" space="true">
        <overload>
        <see>Body:setAllowSleep</see>
		</overload>
      </func>

      <func name="setAllowSleep" brief="Allows or disallows sleeping for this Body.">
        <overload>
    		When nothing happens to a Body in a while (nothing collides with it), it may be put to sleep
			to avoid simulation of that Body for a period of time. This method can be used to disable or enable
			this feature. (Enabled by default).
          <param name="allow" brief="True for allow, false for disallow" />
        </overload>
      </func>

      <func name="setSleep" brief="Puts a Body to sleep or wakes it up." space="true">
        <overload>
        	A Body can be manually put to sleep (woken  up) using this function.
          <param name="sleep" brief="True to put to sleep, false to wake up." />
          <see>Body:setAllowSleep</see>
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the Body.">
        <overload>
          When you don't have time to wait for garbage collection, this function may be used to
          free the object immediately, but note that an error will occur if you attempt to
          use the object after calling this function.[br /]
          [br /]
          Also note that shapes and joints keep internal references to their relevant Bodies in
          order to prevent them from being deallocated while still in use. This means that the Body
          will only be destroyed immediately [i]if[/i] all attatched shapes and joints have been destroyed. 
          If you call Body:destroy before destroying the attatched shapes and joints, the Body will not
          really be destroyed until all relevant shapes and joints are destroyed too.
        </overload>
      </func>

    </type>

    <type name="CircleShape" brief="A simple circle which can be attatched to Bodies.">
    
      <func name="getType" brief="Gets an integer representing the shape type." space="true">
        <overload>
        	This function can be useful for conditional debug drawing.
          <ret name="type" type="number" brief="A constant integer." />
        </overload>
      </func>

      <func name="getFriction" brief="Gets the friction of this shape.">
        <overload>
          <ret name="friction" type="number" brief="The friction of the shape." />
          <see>CircleShape:setFriction</see>
        </overload>
      </func>

      <func name="getRestitution" brief="Gets the restitution of this shape." space="true">
        <overload>
          <ret name="restitution" type="number" brief="The restitution of the shape." />
          <see>CircleShape:setRestitution</see>
        </overload>
      </func>

      <func name="getCategoryBits" brief="Gets the category bits of the shape.">
        <overload>
        	Gets the categories as a 16-bit integer. A set bit indicates membership
        	of that category.
          <ret name="bits" type="number" brief="An integer value representing the categories." />
        </overload>
      </func>

      <func name="getCategory" brief="Gets the categories this shape is a member of.">
        <overload>
          Returns the categories this shape is a member of. The number of categories
          the shape is a member of is the number of return values. Categories are used for
          allowing/disallowing certain collision.
          <ret name="..." type="numbers" brief="Numbers from 1-16" />
        </overload>
      </func>

      <func name="getMaskBits" brief="Gets the mask bits of the shape.">
        <overload>
          Returns a 16-bit integer representing the masked categories. A set bit means
          that a collision occurs with members of that category.
          <ret name="bits" type="number" brief="An integer value representing the mask." />
        </overload>
      </func>

      <func name="getMask" brief="Gets which categories this shape should collide with." space="true">
        <overload>
          Returns the masked categories. The number of masked categories
          is the number of return values.
          <ret name="..." type="numbers" brief="Numbers from 1-16" />
        </overload>
      </func>


      <func name="getData" brief="Gets the data set with setData.">
        <overload>
        	Gets the variable set with CircleShape:setData.
          <ret name="data" type="various" brief="The data previously set, or nil of none." />
          <see>CircleShape:setData</see>
        </overload>
      </func>

      <func name="isSensor" brief="Checks whether this shape acts as a sensor or not" space="true">
        <overload>
          <ret name="sensor" type="boolean" brief="True if sensor, false otherwise." />
          <see>CircleShape:setSensor</see>
        </overload>
      </func>

      <func name="setFriction" brief="Sets the friction of the shape.">
        <overload>
        	Friction determines how shapes react when they "slide" along other shapes.
        	Low friction indicates a slippery surface, like ice, while high friction indicates
			a rough surface, like concrete. Range: 0.0 - 1.0.
          <param name="friction" brief="The friction of the shape." />
        </overload>
      </func>

      <func name="setRestitution" brief="Sets the restitution of the shape." space="true">
        <overload>
        	Restitution indicates the "bounciness" of the shape. High restitution
        	can be used to model stuff like a rubber ball, while low restitution
        	can bse used for "dull" objects, like a bag of sand.
          <param name="restitution" brief="The restitution of the shape." />
        </overload>
      </func>

      <func name="setCategoryBits" brief="Sets the category bits of the shape.">
        <overload>
        	Sets the categories of this shape directly. This function is faster, but
        	more difficult to use than CircleShape:setCategory.
          <param name="bits" brief="An integer value representing the categories." />
        </overload>
      </func>

      <func name="setCategory" brief="Sets the categories this shape is a member of.">
        <overload>
        	Sets the categories of this shape by specifying numbers from 1-16 as parameters. Categories
        	can be used to prevent certain shapes from colliding.
          <param name="..." brief="Numbers from 1-16" />
          <see>CircleShape:setMask</see>
        </overload>
      </func>

      <func name="setMaskBits" brief="Sets the mask bits of the shape." >
        <overload>
        	Sets the mask bits directly. This function is faster, but more difficult to use
        	than CircleShape:setMask.
          <param name="bits" brief="An integer value representing the mask." />
          <see>CircleShape:setMask</see>
        </overload>
      </func>

      <func name="setMask" brief="Sets which categories this shape should collide with." space="true">
        <overload>
        	With this function, you can exclude certain shape categories from collisions with 
        	this shape. The categories passed as parameters will be excluded from collisions - all others
        	included.
          <param name="..." brief="Numbers from 1-16" />
        </overload>
      </func>

      <func name="setData" brief="Sets data to be passed to the collision callback.">
        <overload>
        	When a shape collides, whatever value set here will be passed to the collision callback as one
			of the parameters. Typically, you would want to store a table reference here, 
			but any value can be used.
          <param name="any" brief="Any Lua variable." />
        </overload>
      </func>

      <func name="setSensor" brief="Sets whether this shape should act as a sensor." space="true">
        <overload>
        	Set the shape as a sensor if you want to be notified when collision between shapes occur, but don't want a
        	physical response (for instance, maybe you want enemies to appear when the player "touches" a
        	a certain point).
          <param name="sensor" brief="True for sensor, false otherwise." />
        </overload>
      </func>

      <func name="getBoundingBox" brief="Gets the bounding box of the shape.">
        <overload>
        	This function can be used in a nested fashion with love.graphics.polygon.
          <ret name="x1" type="number" brief="The x-component of the first vertex." />
          <ret name="y1" type="number" brief="The y-component of the first vertex." />
          <ret name="x2" type="number" brief="The x-component of the second vertex." />
          <ret name="y2" type="number" brief="The y-component of the second vertex." />
          <ret name="x3" type="number" brief="The x-component of the third vertex." />
          <ret name="y3" type="number" brief="The y-component of the third vertex." />
          <ret name="x4" type="number" brief="The x-component of the fourth vertex." />
          <ret name="y4" type="number" brief="The y-component of the fourth vertex." />
        </overload>
      </func>

      <func name="testPoint" brief="Checks whether a point lies inside the shape.">
        <overload>
        	This is particularly useful for mouse interaction with the shapes. By looping through
			all shapes and testing the mouse position with this function, we can find which shapes 
			the mouse touches.
          <param name="x" brief="The x-component of the point." />
          <param name="y" brief="The y-component of the point." />
          <ret name="hit" type="boolean" brief="True if inside, false if outside" />
        </overload>
      </func>
      <func name="testSegment" brief="Checks whether a line segment intersects a shape." space="true">
        <overload>
          This function will either return the "time" of impact and the surface normal
          at the point of collision, or nil if the line does not intersect the shape.
          The "time" is a value between 0.0 and 1.0 and can be used to calculate where
          the collision occured.
          <param name="x1" brief="The x-component of the first endpoint." />
          <param name="y1" brief="The y-component of the first endpoint." />
          <param name="x2" brief="The x-component of the second endpoint." />
          <param name="y2" brief="The y-component of the second endpoint." />
          <ret name="t" type="number" brief="The time of impact, or nil if no impact." />
          <ret name="xn" type="number" brief="The x-component of the surface normal." />
          <ret name="yn" type="number" brief="The y-component of the surface normal." />
        </overload>
      </func>
 
      <func name="getRadius" brief="Gets the radius of the CircleShape." space="true">
        <overload>
          Gets the radius of the CircleShape. Note that there is no way to set the radius.
          <ret name="r" type="number" brief="The radius of the circle." />
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the CircleShape.">
        <overload>
          When you don't have time to wait for garbage collection, this function 
          may be used to free the object immediately, but note that an error will 
          occur if you attempt to use the object after calling this function.
          <see>Body:destroy</see>
        </overload>
      </func>
      
    </type>
    <type name="PolygonShape" brief="Convex polygon which can be attatched to Bodies." space="true">

      <func name="getType" brief="Gets an integer representing the shape type." space="true">
        <overload>
          <ret name="type" type="number" brief="A constant integer." />
        </overload>
      </func>

      <func name="getFriction" brief="Gets the friction of this shape.">
        <overload>
          <ret name="friction" type="number" brief="The friction of the shape." />
        </overload>
      </func>

      <func name="getRestitution" brief="Gets the restitution of this shape." space="true">
        <overload>
          <ret name="restitution" type="number" brief="The restitution of the shape." />
        </overload>
      </func>

      <func name="getCategoryBits" brief="Gets the category bits of the shape.">
        <overload>
          <ret name="bits" type="number" brief="An integer value representing the categories." />
        </overload>
      </func>

      <func name="getCategory" brief="Gets the categories this shape is a member of.">
        <overload>
          <ret name="..." type="numbers" brief="Numbers from 1-16" />
        </overload>
      </func>

      <func name="getMaskBits" brief="Gets the mask bits of the shape.">
        <overload>
          <ret name="bits" type="number" brief="An integer value representing the mask." />
        </overload>
      </func>

      <func name="getMask" brief="Gets which categories this shape should collide with." space="true">
        <overload>
          <ret name="..." type="numbers" brief="Numbers from 1-16" />
        </overload>
      </func>


      <func name="getData" brief="Gets the data set with setData.">
        <overload>
          <ret name="data" type="various" brief="The data previously set, or nil of none." />
        </overload>
      </func>

      <func name="isSensor" brief="Checks whether this shape acts as a sensor or not" space="true">
        <overload>
          <ret name="sensor" type="boolean" brief="True if sensor, false otherwise." />
        </overload>
      </func>

      <func name="setFriction" brief="Sets the friction of the shape.">
        <overload>
          <param name="friction" brief="The friction of the shape." />
        </overload>
      </func>

      <func name="setRestitution" brief="Sets the restitution of the shape." space="true">
        <overload>
          <param name="restitution" brief="The restitution of the shape." />
        </overload>
      </func>

      <func name="setCategoryBits" brief="Sets the category bits of the shape.">
        <overload>
          <param name="bits" brief="An integer value representing the categories." />
        </overload>
      </func>

      <func name="setCategory" brief="Sets the categories this shape is a member of.">
        <overload>
          <param name="..." brief="Numbers from 1-16" />
        </overload>
      </func>

      <func name="setMaskBits" brief="Sets the mask bits of the shape." >
        <overload>
          <param name="bits" brief="An integer value representing the mask." />
        </overload>
      </func>

      <func name="setMask" brief="Sets which categories this shape should collide with." space="true">
        <overload>
          <param name="..." brief="Numbers from 1-16" />
        </overload>
      </func>

      <func name="setData" brief="Sets data to be passed to the collision callback.">
        <overload>
          <param name="any" brief="Any Lua variable." />
        </overload>
      </func>

      <func name="setSensor" brief="Sets whether this shape should act as a sensor." space="true">
        <overload>
          <param name="sensor" brief="True for sensor, false otherwise." />
        </overload>
      </func>

      <func name="getBoundingBox" brief="Gets the bounding box of the shape.">
        <overload>
          <ret name="x1" type="number" brief="The x-component of the first vertex." />
          <ret name="y1" type="number" brief="The y-component of the first vertex." />
          <ret name="x2" type="number" brief="The x-component of the second vertex." />
          <ret name="y2" type="number" brief="The y-component of the second vertex." />
          <ret name="x3" type="number" brief="The x-component of the third vertex." />
          <ret name="y3" type="number" brief="The y-component of the third vertex." />
          <ret name="x4" type="number" brief="The x-component of the fourth vertex." />
          <ret name="y4" type="number" brief="The y-component of the fourth vertex." />
        </overload>
      </func>

      <func name="testPoint" brief="Checks whether a point lies inside the shape.">
        <overload>
          <param name="x" brief="The x-component of the point." />
          <param name="y" brief="The y-component of the point." />
          <ret name="hit" type="boolean" brief="True if inside, false if outside" />
        </overload>
      </func>

      <func name="testSegment" brief="Checks whether a line segment intersects a shape." space="true">
        <overload>
          This function will either return the "time" of impact and the surface normal
          at the point of collision, or nil if the line does not intersect the shape.
          The "time" is a value between 0.0 and 1.0 and can be used to calculate where
          the collision occured.
          <param name="x1" brief="The x-component of the first endpoint." />
          <param name="y1" brief="The y-component of the first endpoint." />
          <param name="x2" brief="The x-component of the second endpoint." />
          <param name="y2" brief="The y-component of the second endpoint." />
          <ret name="t" type="number" brief="The time of impact, or nil if no impact." />
          <ret name="xn" type="number" brief="The x-component of the surface normal." />
          <ret name="yn" type="number" brief="The y-component of the surface normal." />
        </overload>
      </func>

      <func name="getPoints" brief="Gets the transformed points of the PolygonShape." space="true">
        <overload>
          <ret name="..." type="numbers" brief="The vertices of the PolygonShape." />
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the PolygonShape.">
        <overload>
          When you don't have time to wait for garbage collection, this function
          may be used to free the object immediately, but note that an error will
          occur if you attempt to use the object after calling this function.
          <see>Body:destroy</see>
        </overload>
      </func>
      
    </type>

    <type name="DistanceJoint" brief="Maintains a certain distance between Bodies.">


      <!-- JOINT 
      <func name="getType" brief="Gets an integer representing the type.">
        <overload>
          <ret name="type" type="number" brief="A constant integer." />
        </overload>
      </func>

      <func name="getAnchors" brief="Gets the anchor points of the joint" space="true">
        <overload>
          <ret name="x1" type="number" brief="The x-component of the anchor on Body 1." />
          <ret name="y1" type="number" brief="The y-component of the anchor on Body 1." />
          <ret name="x2" type="number" brief="The x-component of the anchor on Body 2." />
          <ret name="y2" type="number" brief="The y-component of the anchor on Body 2." />
        </overload>
      </func>

      <func name="getReactionForce" brief="Gets the reaction force on Body 2 at the joint anchor.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the force" />
          <ret name="y" type="number" brief="The y-component of the force" />
        </overload>
      </func>

      <func name="getReactionTorque" brief="Gets the reaction torque on Body 2." space="true">
        <overload>
          <ret name="torque" type="number" brief="The reaction torque on Body 2" />
        </overload>
      </func>

      <func name="getCollideConnected" brief="Gets whether the connected Bodies collide.">
        <overload>
          <ret name="collide" type="boolean" brief="True if they collide, false otherwise." />
        </overload>
      </func>

      <func name="setCollideConnected" brief="Sets whether the connected Bodies should collide with eachother." space="true">
        <overload>
          <param name="collide" brief="True for the Bodies to collide, false otherwise." />
        </overload>
      </func>
      JOINT END -->

      <func name="getLength" brief="Gets the equilibrium distance between the two Bodies.">
        <overload>
          <ret name="length" type="number" brief="The length between the two Bodies." />
        </overload>
      </func>

      <func name="getFrequency" brief="Gets the response speed.">
        <overload>
          <ret name="hz" type="number" brief="The response speed." />
        </overload>
      </func>

      <func name="getDamping" brief="Gets the damping ratio." space="true">
        <overload>
          <ret name="damping" type="number" brief="The damping ratio." />
        </overload>
      </func>





      <func name="setLength" brief="Sets the equilibrium distance between the two Bodies.">
        <overload>
          <param name="length" brief="The length between the two Bodies." />
        </overload>
      </func>

      <func name="setFrequency" brief="Sets the response speed.">
        <overload>
          <param name="hz" brief="The response speed" />
        </overload>
      </func>

      <func name="setDamping" brief="Sets the damping ratio." space="true">
        <overload>
          <param name="d" brief="The damping ratio." />
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the DistanceJoint.">
        <overload>
          When you don't have time to wait for garbage collection, this function
          may be used to free the object immediately, but note that an error will
          occur if you attempt to use the object after calling this function.
          <see>Body:destroy</see>
        </overload>
      </func>

    </type>
    <type name="RevoluteJoint" brief="Allow two Bodies to revolve around a shared point.">
      <!-- JOINT 
      <func name="getType" brief="Gets an integer representing the type.">
        <overload>
          <ret name="type" type="number" brief="A constant integer." />
        </overload>
      </func>

      <func name="getAnchors" brief="Gets the anchor points of the joint" space="true">
        <overload>
          <ret name="x1" type="number" brief="The x-component of the anchor on Body 1." />
          <ret name="y1" type="number" brief="The y-component of the anchor on Body 1." />
          <ret name="x2" type="number" brief="The x-component of the anchor on Body 2." />
          <ret name="y2" type="number" brief="The y-component of the anchor on Body 2." />
        </overload>
      </func>

      <func name="getReactionForce" brief="Gets the reaction force on Body 2 at the joint anchor.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the force" />
          <ret name="y" type="number" brief="The y-component of the force" />
        </overload>
      </func>

      <func name="getReactionTorque" brief="Gets the reaction torque on Body 2." space="true">
        <overload>
          <ret name="torque" type="number" brief="The reaction torque on Body 2" />
        </overload>
      </func>

      <func name="getCollideConnected" brief="Gets whether the connected Bodies collide.">
        <overload>
          <ret name="collide" type="boolean" brief="True if they collide, false otherwise." />
        </overload>
      </func>

      <func name="setCollideConnected" brief="Sets whether the connected Bodies should collide with eachother." space="true">
        <overload>
          <param name="collide" brief="True for the Bodies to collide, false otherwise." />
        </overload>
      </func>
      JOINT END -->

      <func name="getAngle" brief="Get the current joint angle.">
        <overload>
          <ret name="angle" type="number" brief="The joint angle in degrees." />
        </overload>
      </func>

      <func name="getSpeed" brief="Get the current joint angle speed." space="true">
        <overload>
          <ret name="" type="number" brief="Joint angle speed in degrees/second." />
        </overload>
      </func>

      <func name="isMotorEnabled" brief="Checks whether the motor is enabled.">
        <overload>
          <ret name="enabled" type="boolean" brief="True if enabled, false if disabled." />
        </overload>
      </func>

      <func name="getMaxMotorTorque" brief="Gets the maximum motor torque.">
        <overload>
          <ret name="torque" type="number" brief="The maximum motor torque, usually in N-m." />
        </overload>
      </func>

      <func name="getMotorSpeed" brief="Gets the motor speed.">
        <overload>
          <ret name="speed" type="number" brief="The motor speed in degrees per second." />
        </overload>
      </func>

      <func name="getMotorTorque" brief="Get the current motor torque." space="true">
        <overload>
          <ret name="torque" type="number" brief="The current motor torque, usually in N-m." />
        </overload>
      </func>

      <func name="isLimitsEnabled" brief="Checks whether limits are enabled.">
        <overload>
          <ret name="enabled" type="number" brief="" />
        </overload>
      </func>

      <func name="getLowerLimit" brief="Gets the lower limit.">
        <overload>
          <ret name="lower" type="number" brief="The lower limit in degrees." />
        </overload>
      </func>

      <func name="getUpperLimit" brief="Gets the upper limit.">
        <overload>
          <ret name="upper" type="number" brief="The upper limit in degrees." />
        </overload>
      </func>

      <func name="getLimits" brief="Gets the joint limits." space="true">
        <overload>
          <ret name="lower" type="number" brief="The lower limit in degrees." />
          <ret name="upper" type="number" brief="The upper limit in degrees." />
        </overload>
      </func>

      <func name="setMotorEnabled" brief="Enables/disables the joint motor.">
        <overload>
          <param name="motor" brief="True to enable, false to disable." />
        </overload>
      </func>

      <func name="setMaxMotorTorque" brief="Set the maximum motor torque.">
        <overload>
          <param name="torque" brief="Motor torque, usually in N-m." />
        </overload>
      </func>

      <func name="setMotorSpeed" brief="Sets the motor speed." space="true">
        <overload>
          <param name="speed" brief="Speed in degrees per second." />
        </overload>
      </func>

      <func name="setLimitsEnabled" brief="Enables/disables the joint limit.">
        <overload>
          <param name="limit" brief="True to enable, false to disable." />
        </overload>
      </func>

      <func name="setUpperLimit" brief="Sets the upper limit.">
        <overload>
          <param name="upper" brief="Limit in degrees." />
        </overload>
      </func>

      <func name="setLowerLimit" brief="Sets the lower limit.">
        <overload>
          <param name="lower" brief="Limit in degrees." />
        </overload>
      </func>

      <func name="setLimits" brief="Sets the limits." space="true">
        <overload>
          <param name="lower" brief="Lower limit in degrees." />
          <param name="upper" brief="Upper limit in degrees." />
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the RevoluteJoint.">
        <overload>
          When you don't have time to wait for garbage collection, this function
          may be used to free the object immediately, but note that an error will
          occur if you attempt to use the object after calling this function.
          <see>Body:destroy</see>
        </overload>
      </func>
      
    </type>
    <type name="PrismaticJoint" brief="Restricts relative motion between Bodies to one shared axis.">
      <!-- JOINT 
      <func name="getType" brief="Gets an integer representing the type.">
        <overload>
          <ret name="type" type="number" brief="A constant integer." />
        </overload>
      </func>

      <func name="getAnchors" brief="Gets the anchor points of the joint" space="true">
        <overload>
          <ret name="x1" type="number" brief="The x-component of the anchor on Body 1." />
          <ret name="y1" type="number" brief="The y-component of the anchor on Body 1." />
          <ret name="x2" type="number" brief="The x-component of the anchor on Body 2." />
          <ret name="y2" type="number" brief="The y-component of the anchor on Body 2." />
        </overload>
      </func>

      <func name="getReactionForce" brief="Gets the reaction force on Body 2 at the joint anchor.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the force" />
          <ret name="y" type="number" brief="The y-component of the force" />
        </overload>
      </func>

      <func name="getReactionTorque" brief="Gets the reaction torque on Body 2." space="true">
        <overload>
          <ret name="torque" type="number" brief="The reaction torque on Body 2" />
        </overload>
      </func>

      <func name="getCollideConnected" brief="Gets whether the connected Bodies collide.">
        <overload>
          <ret name="collide" type="boolean" brief="True if they collide, false otherwise." />
        </overload>
      </func>

      <func name="setCollideConnected" brief="Sets whether the connected Bodies should collide with eachother." space="true">
        <overload>
          <param name="collide" brief="True for the Bodies to collide, false otherwise." />
        </overload>
      </func>
      JOINT END -->


      <func name="getTranslation" brief="Get the current joint translation.">
        <overload>
          <ret name="translation" type="number" brief="Joint translation, usually in meters.." />
        </overload>
      </func>

      <func name="getSpeed" brief="Get the current joint angle speed." space="true">
        <overload>
          <ret name="speed" type="number" brief="Joint angle speed in meters/second." />
        </overload>
      </func>

      <func name="isMotorEnabled" brief="Checks whether the motor is enabled.">
        <overload>
          <ret name="enabled" type="boolean" brief="True if enabled, false if disabled." />
        </overload>
      </func>

      <func name="getMaxMotorForce" brief="Gets the maximum motor force.">
        <overload>
          <ret name="force" type="number" brief="The maximum motor force, usually in N." />
        </overload>
      </func>

      <func name="getMotorSpeed" brief="Gets the motor speed.">
        <overload>
          <ret name="speed" type="number" brief="The motor speed, usually in meters per second." />
        </overload>
      </func>

      <func name="getMotorForce" brief="Get the current motor force." space="true">
        <overload>
          <ret name="force" type="number" brief="The current motor force, usually in N." />
        </overload>
      </func>

      <func name="isLimitsEnabled" brief="Checks whether limits are enabled.">
        <overload>
          <ret name="enabled" type="number" brief="" />
        </overload>
      </func>

      <func name="getLowerLimit" brief="Gets the lower limit.">
        <overload>
          <ret name="lower" type="number" brief="The lower limit, usually in meters." />
        </overload>
      </func>

      <func name="getUpperLimit" brief="Gets the upper limit.">
        <overload>
          <ret name="upper" type="number" brief="The upper limit, usually in meters." />
        </overload>
      </func>

      <func name="getLimits" brief="Gets the joint limits." space="true">
        <overload>
          <ret name="lower" type="number" brief="The lower limit, usually in meters." />
          <ret name="upper" type="number" brief="The upper limit, usually in meters." />
        </overload>
      </func>

      <func name="setMotorEnabled" brief="Enables/disables the joint motor.">
        <overload>
          <param name="motor" brief="True to enable, false to disable." />
        </overload>
      </func>

      <func name="setMaxMotorForce" brief="Set the maximum motor force.">
        <overload>
          <param name="force" brief="Motor force, usually in N." />
        </overload>
      </func>

      <func name="setMotorSpeed" brief="Sets the motor speed." space="true">
        <overload>
          <param name="speed" brief="Speed, usually in meters per second." />
        </overload>
      </func>

      <func name="setLimitsEnabled" brief="Enables/disables the joint limit.">
        <overload>
          <param name="limit" brief="True to enable, false to disable." />
        </overload>
      </func>

      <func name="setUpperLimit" brief="Sets the upper limit.">
        <overload>
          <param name="upper" brief="Upper limit, usually in meters." />
        </overload>
      </func>

      <func name="setLowerLimit" brief="Sets the lower limit.">
        <overload>
          <param name="lower" brief="Lower limit, usually in meters." />
        </overload>
      </func>

      <func name="setLimits" brief="Sets the limits." space="true">
        <overload>
          <param name="lower" brief="Lower limit, usually in meters." />
          <param name="upper" brief="Upper limit, usually in meters." />
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the PrismaticJoint.">
        <overload>
          When you don't have time to wait for garbage collection, this function
          may be used to free the object immediately, but note that an error will
          occur if you attempt to use the object after calling this function.
          <see>Body:destroy</see>
        </overload>
      </func>

    </type>
    <type name="MouseJoint" brief="For controlling objects with the mouse.">

      <!-- JOINT 
      <func name="getType" brief="Gets an integer representing the type.">
        <overload>
          <ret name="type" type="number" brief="A constant integer." />
        </overload>
      </func>

      <func name="getAnchors" brief="Gets the anchor points of the joint" space="true">
        <overload>
          <ret name="x1" type="number" brief="The x-component of the anchor on Body 1." />
          <ret name="y1" type="number" brief="The y-component of the anchor on Body 1." />
          <ret name="x2" type="number" brief="The x-component of the anchor on Body 2." />
          <ret name="y2" type="number" brief="The y-component of the anchor on Body 2." />
        </overload>
      </func>

      <func name="getReactionForce" brief="Gets the reaction force on Body 2 at the joint anchor.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the force" />
          <ret name="y" type="number" brief="The y-component of the force" />
        </overload>
      </func>

      <func name="getReactionTorque" brief="Gets the reaction torque on Body 2." space="true">
        <overload>
          <ret name="torque" type="number" brief="The reaction torque on Body 2" />
        </overload>
      </func>

      <func name="getCollideConnected" brief="Gets whether the connected Bodies collide.">
        <overload>
          <ret name="collide" type="boolean" brief="True if they collide, false otherwise." />
        </overload>
      </func>

      <func name="setCollideConnected" brief="Sets whether the connected Bodies should collide with eachother." space="true">
        <overload>
          <param name="collide" brief="True for the Bodies to collide, false otherwise." />
        </overload>
      </func>
      JOINT END -->

      <func name="getTarget" brief="Gets the target point.">
        <overload>
          <ret name="x" type="number" brief="The x-component of the target." />
          <ret name="y" type="number" brief="The x-component of the target." />
        </overload>
      </func>

      <func name="getMaxForce" brief="Gets the max allowed force on the Body." space="true">
        <overload>
          <ret name="force" type="number" brief="The max allowed force." />
        </overload>
      </func>

      <func name="setTarget" brief="Sets the target point.">
        <overload>
          <param name="x" brief="The x-component of the target." />
          <param name="y" brief="The x-component of the target." />
        </overload>
      </func>

      <func name="setMaxForce" brief="Gets the max allowed force on the Body." space="true">
        <overload>
          <ret name="force" type="number" brief="The max allowed force." />
        </overload>
      </func>

      <func name="destroy" brief="Explicitly destroys the MouseJoint.">
        <overload>
          When you don't have time to wait for garbage collection, this function
          may be used to free the object immediately, but note that an error will
          occur if you attempt to use the object after calling this function.
          <see>Body:destroy</see>
        </overload>
      </func>

    </type>

    <func name="newWorld" brief="Creates a new World." space="true">
      <overload>
        This function creates a new World with the given size,
        no gravity and sleeping turned on.
        <param name="w" brief="The width of the World." />
        <param name="h" brief="The height of the World." />
        <ret name="world" type="World" brief="A World object."/>
      </overload>
      <overload>
        This function creates a new World with an area defined by the two vertices,
        the given gravity, and sleeping turned on or off.
        <param name="lx" brief="X-component of lower left corner of the World area." />
        <param name="ly" brief="Y-component of lower left corner of the World area." />
        <param name="ux" brief="X-component of upper right corner of the World area." />
        <param name="uy" brief="Y-component of upper right corner of the World area." />
        <param name="gx" brief="X-component of the gravity." />
        <param name="gy" brief="Y-component of the gravity." />
        <param name="sleep" brief="True to allow sleep, false otherwise." />
        <ret name="world" type="World" brief="A World object."/>
      </overload>
    </func>

    <func name="newBody" brief="Creates a new Body." space="true">
      <overload>
        <param name="world" brief="The World to create the Body in." />
        <ret name="body" type="Body" />
      </overload>
      <overload brief="Creates a new Body with some position.">
        <param name="world" brief="The World to create the Body in." />
        <param name="x" brief="The x-component of the position." />
        <param name="y" brief="The y-component of the position." />
        <ret name="body" type="Body" />
      </overload>
      <overload brief="Creates a new Body with some position and mass.">
        <param name="world" brief="The World to create the Body in." />
        <param name="x" brief="The x-component of the position." />
        <param name="y" brief="The y-component of the position." />
        <param name="m" brief="The mass of the Body." />
        <ret name="body" type="Body" />
      </overload>
    </func>

    <func name="newCircleShape" brief="Creates a new CircleShape." space="true">
      <overload>
        <param name="body" brief="A Body to attatch the CircleShape to." />
        <param name="radius" brief="The radius of the circle." />
        <ret name="circle" type="Circle" brief="A CircleShape." />
      </overload>
      <overload brief="Creates a new CircleShape with an offset.">
        <param name="body" brief="A Body to attatch the CircleShape to." />
        <param name="x" brief="The x-component of the circle offset." />
        <param name="y" brief="The y-component of the circle offset." />
        <param name="radius" brief="The radius of the circle." />
        <ret name="circle" type="Circle" brief="A CircleShape." />
      </overload>
    </func>

    <func name="newRectangleShape" brief="Creates a new rectangular PolygonShape." space="true">
      <overload brief="Creates a rectangle.">
        <param name="body" brief="The Body to attatch the rectangle to." />
        <param name="w" brief="The width of the rectangle." />
        <param name="h" brief="The height of the rectangle." />
        <ret name="rectangle" type="PolygonShape" brief="A rectangular PolygonShape." />
      </overload>
      <overload brief="Creates a new rectangle with an offset.">
        <param name="body" brief="The Body to attatch the rectangle to." />
        <param name="x" brief="The x-component of the offset." />
        <param name="y" brief="The y-component of the offset." />
        <param name="w" brief="The width of the rectangle." />
        <param name="h" brief="The height of the rectangle." />
        <ret name="rectangle" type="PolygonShape" brief="A rectangular PolygonShape." />
      </overload>
      <overload brief="Creates a new rectangle with offset and orientation.">
        <param name="body" brief="The Body to attatch the rectangle to." />
        <param name="x" brief="The x-component of the offset." />
        <param name="y" brief="The y-component of the offset." />
        <param name="w" brief="The width of the rectangle." />
        <param name="h" brief="The height of the rectangle." />
        <param name="angle" brief="The orientation of the rectangle (degrees)." />
        <ret name="rectangle" type="PolygonShape" brief="A rectangular PolygonShape." />
      </overload>
    </func>

    <func name="newPolygonShape" brief="Creates a new PolygonShape." space="true">
      <overload>
        <param name="body" brief="The Body to attatch the polygon to." />
        <param name="..." brief="The vertices of the PolygonShape." />
        <ret name="polygon" type="PolygonShape" brief="The new PolygonShape." />
      </overload>
    </func>

    <func name="newDistanceJoint" brief="Creates a new DistanceJoint.">
      <overload>
        <param name="body1" brief="The first Body to attatch the joint to." />
        <param name="body2" brief="The second Body to attatch the joint to." />
        <param name="x1" brief="The x-component of the first anchor point." />
        <param name="y1" brief="The y-component of the first anchor point." />
        <param name="x2" brief="The x-component of the second anchor point." />
        <param name="y2" brief="The y-component of the second anchor point." />
        <ret name="distancejoint" type="DistanceJoint" brief="The new DistanceJoint." />
      </overload>
    </func>

    <func name="newRevoluteJoint" brief="Creates a new RevoluteJoint.">
      <overload>
        <param name="body1" brief="The first Body to attatch the joint to." />
        <param name="body2" brief="The second Body to attatch the joint to." />
        <param name="x" brief="The x-component of the anchor point." />
        <param name="y" brief="The y-component of the anchor point." />
        <ret name="revolutejoint" type="RevoluteJoint" brief="The new RevoluteJoint." />
      </overload>
    </func>

    <func name="newPrismaticJoint" brief="Creates a new PrismaticJoint.">
      <overload>
        <param name="body1" brief="The first Body to attatch the joint to." />
        <param name="body2" brief="The second Body to attatch the joint to." />
        <param name="x" brief="The x-component of the anchor point." />
        <param name="y" brief="The y-component of the anchor point." />
        <param name="ax" brief="The x-component of the axis." />
        <param name="ay" brief="The y-component of the axis." />
        <ret name="prismaticjoint" type="PrismaticJoint" brief="The new PrismaticJoint." />
      </overload>
    </func>

    <func name="newMouseJoint" brief="Creates a new MouseJoint">
      <overload>
        <param name="body" brief="The first Body to attatch the joint to." />
        <param name="x" brief="The x-component of the anchor point." />
        <param name="y" brief="The y-component of the anchor point." />
        <ret name="mousejoint" type="MouseJoint" brief="The new MouseJoint." />
      </overload>
    </func>

  </module>
  <module name="love.mouse">
    Keeps track of the state of the mouse.

    <func name="getX" brief="Gets the current x-position of the mouse.">
      <overload>
        Gets the current x-position of the mouse. Use this if you for some reason
        only need the position along the x-axis. Otherwise, you probably want to use love.mouse.getPosition.
        <ret name="x" type="number" brief="Current x-position." />
        <see>
          love.mouse.getPosition, love.mouse.getY
        </see>
        <example id="3" />
      </overload>
    </func>

    <func name="getY" brief="Gets the current y-position of the mouse." space="true">
      <overload>
        Gets the current y-position of the mouse. Use this if you for some reason
        only need the position along the y-axis. Otherwise, you probably want to use love.mouse.getPosition.
        <ret name="y" type="number" brief="Current y-position." />
        <see>
          love.mouse.getPosition, love.mouse.getX
        </see>
        <example id="3" />
      </overload>
    </func>

    <func name="getPosition" brief="Gets the current position of the mouse.">
      <overload>
        Gets the current x- and y-position of the mouse in one call. Since getting the mouse position (along both axes) is
        a fairly common task, this func was created to make it prettier.
        <ret name="x" type="number" brief="The current x position." />
        <ret name="y" type="number" brief="The current y position." />
        <example id="2" />
      </overload>
    </func>

    <func name="setPosition" brief="Sets the current position of the mouse." space="true">
      <overload>
        Sets the current position of the mouse. Note that this generates a mousemoved event.
        If you just want to confine the mouse to the screen area, take a look at love.system.grabInput.
        <param name="x" brief="The new x-position." />
        <param name="y" brief="The new y-position." />
        <see>
          love.system.grabInput
        </see>
        <example id="4" />
      </overload>
    </func>


    <func name="isDown" brief="Checks whether a certain button is down." space="true">
      <overload>
        Checks whether a certain mouse button is down.
        <param name="button" brief="A mouse button." />
        <ret name="down" type="boolean" brief="Whether the button is down." />
        <see>
          Constants
        </see>
        <example id="5" />
      </overload>
    </func>

    <func name="setVisible" brief="Controls cursor visbility.">
      <overload>
        Controls cursor visbility. Goes great with love.system.grabInput.
        <param name="visible" brief="True for visible, false for invisible." />
        <see>
          love.system.grabInput
        </see>
        <example id="6" />
      </overload>
    </func>

    <func name="isVisible" brief="Checks cursor visbility.">
      <overload>
        Checks cursor visbility.
        <ret name="visible" type="boolean" brief="True if visible, false otherwise." />
        <see>
          love.mouse.setVisible
        </see>
        <example id="6" />
      </overload>
    </func>

    <example id="2" />

  </module>

  <module name="love.keyboard">
    Keeps track of the state of the keyboard.

    <func name="isDown" brief="Checks whether a certain key is down.">
      <overload>
        Checks whether a certain key is down. For list of accepted keys, see Constants.
        <param name="key" brief="The key in question." />
        <ret type="boolean" brief="Whether the passed key is pressed down." />
        <see>
          Constants, keypressed, keyrelreased
        </see>
        <example id="10" />
      </overload>
    </func>
    <example id="10" />
  </module>

  <module name="love.joystick">
    This module provides access to information and events regarding joysticks, gamepads,
    steering wheels, and similar devices. [br /]
    [br /]
    Since we need to deal with multiple joysticks on the same system, they are
    given a numeric value from 0 and up (the "first" joystick is #0, the "second" is #1).
    <func name="getName" brief="Gets the name of a joystick.">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <ret name="name" type="string" brief="The name of the joystick" />
      </overload>
    </func>
    <func name="getNumJoysticks" brief="Gets the number of joysticks.">
      <overload>
        <ret name="num" type="number" brief="The number of joysticks" />
      </overload>
    </func>
    <func name="getNumAxes" brief="Gets the number of axes on a joystick">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <ret name="num" type="number" brief="The number of axes." />
      </overload>
    </func>
    <func name="getNumBalls" brief="Gets the number of trackballs on a joystick">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <ret name="num" type="number" brief="The number of trackballs." />
      </overload>
    </func>
    <func name="getNumButtons" brief="Gets the number buttons on a joystick">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <ret name="num" type="number" brief="The number of buttons." />
      </overload>
    </func>
    <func name="getNumHats" brief="Gets the number viewhats on a joystick" space="true">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <ret name="num" type="number" brief="The number of viewhats." />
      </overload>
    </func>

    <func name="isDown" brief="Checks if a button is down.">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <param name="button" brief="The button number." />
        <ret name="down" type="boolean" brief="True if down, false if not." />
      </overload>
    </func>
    <func name="getAxis" brief="Gets the state of an axis.">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <param name="axis" brief="The axis number." />
        <ret name="pos" type="number" brief="The position of the axis." />
        <see>love.joystick.getNumAxes</see>
      </overload>
    </func>
    <func name="getAxes" brief="Gets the states of the axes.">
      <overload>
        The range of an axis is -1.0 to 1.0. The number of return values
        is the number returned by love.joystick.getNumAxes.
        <param name="joystick" brief="The joystick number." />
        <ret name="..." brief="The positions of the axes." />
        <see>love.joystick.getNumAxes</see>
      </overload>
    </func>
    <func name="getBall" brief="Gets the relative position of a trackball.">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <param name="ball" brief="The ball number." />
        <ret name="x" type="number" brief="The change on the x-axis since last call." />
        <ret name="y" type="number" brief="The change on the y-axis since last call." />
      </overload>
    </func>
    <func name="getHat" brief="Gets the state of a viewhat." space="true">
      <overload>
        <param name="joystick" brief="The joystick number." />
        <param name="viewhat" brief="The viewhat number." />
        <ret name="state" type="number" brief="A constant indicating the state. (See Constants)." />
      </overload>
    </func>
    <func name="open" brief="Opens a joystick.">
      <overload>
        Note that all joysticks are automatically opened. You only need to use this if
        you previously closed a joystick.
        <param name="joystick" brief="The joystick number"/>
      </overload>
    </func>
    <func name="isOpen" brief="Checks whether a joystick is open.">
      <overload>
        <param name="joystick" brief="The joystick number"/>
        <ret name="open" type="boolean" brief="True if open, false if closed." />
      </overload>
    </func>
    <func name="close" brief="Closes a joystick">
      <overload>
        Although leaving joysticks open cause no harm, you
        can choose to close them if you don't need them.
        <param name="joystick" brief="The joystick number" />
      </overload>
    </func>

  </module>
 
  <module name="love.filesystem">
    This module provides access to Files in two places, and two places only:
    [ul]
    [li]The root folder of the .love-file. (Alternatively a directory).[/li]
    [li]The root folder of the save directory.[/li]
    [/ul]
    Each game is granted a single diretory on the user system where files can be saved.
    Full access to normal file I/O is no longer present due to security concerns.
    The directories will typically be something like:
    [ul]
    [li]C:\Documents and Settings\user\Application Data\LOVE\game[/li]
    [li]/home/user/.love/game[/li]
    [/ul]
    Files that are opened for write or append will always be created in the
    save directory. The same goes for other operations that involve writing to
    the filesystem, like mkdir.
    [p]
    Files that are opened for read will be looked for in the game root folder, and then
    the save directory (in that order). So if a file with a certain filename (and
    path) exist in both the .love-file and the save folder, the one in the .love-file takes precedence.
    [/p]

    <type name="File" brief="A file that can be read from or written to.">
      A File should only be needed in these situations:
      [ul]
      [li]You need to read data directly from a file.[/li]
      [li]You need to write to a file.[/li]
      [/ul]
      In other cases, you can (and must) specify filenames directly when creating objects
      such as Image, Font and Sound.
      <func name="getSize" brief="Gets the size of the file in bytes.">
        <overload>
          <ret type="number" brief="The size of the file." />
          Gets the size of the file in bytes. This requires that the File was created for reading, otherwise this functioin will return 0.
        </overload>
      </func>
      <see>love.filesystem.newFile</see>
    </type>

    <func name="newFile" brief="Constructs a File with the given filename." space="true">
      <overload>
        <param name="filename" brief="The filename." />
        <ret type="File" brief="The newly created file." />
        The file is in read mode only.
      </overload>
      <overload>
        <param name="filename" brief="The filename." />
        <param name="mode" brief="The filesystem mode (read, write, append)." />
        <ret type="File" brief="The newly created file." />
      </overload>
    </func>

    <func name="getWorkingDirectory" brief="Gets the current working directory.">
      <overload>
        <ret name="cwd" type="string" brief="The current working directory." />
      </overload>
    </func>

    <func name="getSaveDirectory" brief="Gets the full path to the designated save directory." space="true">
      <overload>
        <ret name="savedir" type="string" brief="The save directory." />
      </overload>
    </func>

    <func name="exists" brief="Check whether a file exists.">
      <overload>
        <param name="filename" brief="The name of the file to check." />
        <ret type="boolean" brief="Whether the file exists." />
      </overload>
    </func>

    <func name="isDirectory" brief="Check whether something is a directory.">
      <overload>
        <param name="dirname" brief="Name of the directory to check." />
        <ret type="boolean" brief="Whether it's a directory." />
      </overload>
    </func>

    <func name="isFile" brief="Check whether something is a file." space="true">
      <overload>
        <param name="filename" brief="Name of the file to check." />
        <ret type="boolean" brief="Whether it's a file." />
      </overload>
    </func>

    <func name="mkdir" brief="Creates a directory.">
      <overload>
        <param name="dirname" brief="Name of the new directory." />
        <ret type="boolean" brief="Whether the operation was successful." />
      </overload>
    </func>

    <func name="remove" brief="Removes a file (or directory)." space="true">
      <overload>
        <param name="filename" brief="Name of the file (or directory(." />
        <ret type="boolean" brief="Whether the operation was successful." />
      </overload>
    </func>

    <func name="open" brief="Opens the file for reading/writing (depending on its mode).">
      <overload>
        <param name="file" brief="A File object of the file to open." />
        <ret type="boolean" brief="Whether the operation was successful." />
        <see>love.filesystem.newFile, love.filesystem.close</see>
      </overload>
    </func>

    <func name="close" brief="Closes the file." space="true">
      <overload>
        <param name="file" brief="A File object of the file to close." />
        <ret type="boolean" brief="Whether the operation was successful." />
        <see>love.filesystem.newFile, love.filesystem.open</see>
      </overload>
    </func>

    <func name="read" brief="Reads bytes from an opened File.">
      <overload>
        <param name="file" brief="An opened File object of the file to read." />
        <ret type="string" name="contents" brief="The bytes contained in the file." />
        <see>love.filesystem.newFile, love.filesystem.open</see>
      </overload>
      <overload>
        <param name="file" brief="An opened File object of the file to read." />
        <param name="bytes" brief="The amount of bytes to open." />
        <ret type="string" name="contents" brief="The bytes contained in the file." />
        <see>love.filesystem.newFile, love.filesystem.open</see>
      </overload>
      <overload brief="Quick read using filename.">
        When using filenames instead of filehandles, a File object is created, opened and closed
        for you behind the scenes.
        <param name="filename" brief="The filepath to the File." />
        <ret type="string" name="contents" brief="The bytes contained in the file." />
      </overload>
      <overload brief="Quick read using filename.">
        When using filenames instead of filehandles, a File object is created, opened and closed
        for you behind the scenes.
        <param name="filename" brief="The filepath to the File." />
        <param name="bytes" brief="The amount of bytes to open." />
        <ret type="string" name="contents" brief="The bytes contained in the file." />
      </overload>
    </func>

    <func name="write" brief="Writes bytes to an opened File." space="true">
      <overload>
        <param name="file" brief="An opened File object of the file to write to." />
        <param name="data" brief="A string of bytes to write to the file." />
        <ret type="boolean" name="success" brief="Whether the operation was successful." />
        <see>love.filesystem.newFile, love.filesystem.open</see>
      </overload>
      <overload brief="Quick write using filename.">
        When using filenames instead of filehandles, a File object is created, opened and closed
        for you behind the scenes.
        <param name="filename" brief="Filename of the File to write." />
        <param name="data" brief="A string of bytes to write to the file." />
        <ret type="boolean" name="success" brief="Whether the operation was successful." />
      </overload>
    </func>

    <func name="lines" brief="Iterate the lines in a File." space="true">
      <overload>
        This function returns an iterator function which can be used with Lua's generic for.
        <param name="file" brief="An open File handle." />
        <example id="103" />
      </overload>
      <overload>
        This function returns an iterator function which can be used with Lua's generic for.
        When using filenames instead of filehandles, a File object is created, opened and closed
        for you behind the scenes.
        <param name="filename" brief="Filename of the File to read." />
        <example id="103" />
      </overload>
    </func>

    <func name="eof" brief="Check if end-of-file is reached.">
      <overload>
        <param name="file" brief="A File object." />
        <ret type="boolean" brief="Whether the EOF has been reached." />
        <see>love.filesystem.read</see>
      </overload>
    </func>

    <func name="tell" brief="Gets the current position in a file.">
      <overload>
        <param name="file" brief="A File object." />
        <ret type="number" brief="The current position." />
        <see>love.filesystem.read</see>
      </overload>
    </func>

    <func name="seek" brief="Seek to a position within a file.">
      <overload>
        <param name="file" brief="A File object." />
        <param name="pos" brief="The position to seek to." />
        <ret type="boolean" brief="Whether the operation was successful." />
        <see>love.filesystem.read</see>
      </overload>
    </func>

    <func name="enumerate" brief="Gets a list of files in the given directory." space="true">
      <overload>
        <param name="dir" brief="A directory." />
        <ret type="list" brief="All the files (and subdirs) in the directory." />
      </overload>
    </func>

    <func name="require" brief="Includes and runs a Lua file (once).">
      <overload>
        <param name="filename" brief="The filename of the file to read." />
        It is safe to require the same file more than once. LÖVE keeps track of required
        files to prevent reparsing. (If you want the same file to be executed multiple
        times, take a look at {love.filesystem.include}.
        <see>
          love.filesystem.include
        </see>
      </overload>
    </func>

    <func name="include" brief="Includes and runs a Lua file.">
      <overload>
        <param name="filename" brief="The filename of the file to read." />
        Includes and runs a Lua file every time the function is called. (Does not check if the file is included already).

        <see>
          love.filesystem.require
        </see>

      </overload>
    </func>

    <func name="load" brief="Loads a Lua-file without running it.">
      <overload>
        The loaded Lua chunk is returned as a function.
        <param name="filename" brief="The filename of the File to read." />
        <ret name="f" type="function" brief="The loaded chunk." />
      </overload>
    </func>

  </module>
  <module name="love.timer">

    The timer module keeps track of time between frames, so that game
    objects can be updated in a FPS-independet fashion. The precision of the
    timer is usually 1ms, although this [i]may[/i] vary from system to system. Hardware timers
    with higher precision are planned, but not implemented at the time of writing.

    <func name="getFPS" brief="Gets the current FPS.">
      <overload>
        ret the current frames-per-second. Since it is meant for display-purposes,
        the value is only updated each second (this makes the value non-erratic and human-readable
        when drawn on screen).
        <ret type="number" brief="The FPS." />
        <example id="8" />
      </overload>
    </func>
    <func name="getDelta" brief="ret the current timestep.">
      <overload>
        ret the time (in seconds) since last frame. This is the same value that is
        passed with the update-callback each frame, so you should't really need to
        use this func for antying but display purposes.
        <example id="8" />
      </overload>
      <ret type="number" brief="The current timestep." />
    </func>
    <func name="sleep" brief="Delays exection for an amount of time.">
      <overload>
        <param name="ms" brief="The amount of milliseconds." />
        Delays execution for the specified amount of milliseconds. Tragically,
        the precision varies from system to system, and is generally not very good.
        Do not expect to get better precision than the nearest 10ms.
        <example id="7" />
      </overload>
    </func>
    <func name="getTime" brief="Gets approximate time since startup.">
      <overload>
        Note that this func does not get the current time! It is meant for
        timing pieces of code. [br /][br /]Also, this func is not very precise at the moment,
        since SDL's timer is used. This will change in some time in the future when modules for timers
        with higher resolutions are created.
        <ret type="number" brief="The (approximate) time in seconds since startup." />
        <example id="9" />
      </overload>
    </func>

    <example id="7" />
    <example id="9" />

  </module>
  <module name="love.system">

    The system module controls the currently running game and provides information about
    the running LOVE version. It is not related to the underlying operating system.
    <func name="getVersion" brief="Gets the current LOVE version.">
      <overload>
        <ret type="string" brief="String containing the version." />
      </overload>
    </func>
    <func name="getCodename" brief="Gets the codename of the current LOVE version.">
      <overload>
        <ret type="string" brief="String containing the codename." />
      </overload>
    </func>
    <func name="getPlatform" brief="Gets the current platform." space="true">
      <overload>
        <ret type="string" brief="String containing Windows, Linux ..." />
      </overload>
    </func>
    <func name="exit" brief="Exits LOVE.">
      <overload>
        Calling this func will immediately exit LOVE and free resources.
      </overload>
    </func>
    <func name="restart" brief="Restarts the current game.">
      <overload>
        The current immediately restarts.
      </overload>
    </func>
    <func name="suspend" brief="Takes LOVE to the error handler.">
      <overload>
        Calling this func will cause LOVE to enter error mode, just like when
        an error occurs. NOTE! If you actually want to cause an error, do not
        call this func, use the built-in Lua func error() instead.
      </overload>
    </func>
    <func name="resume" brief="Takes LOVE back to the main game." space="true">
      <overload>
        This func is meant to be called from error handler scripts, and has no
        effect if called from a normal game.
      </overload>
    </func>
    <func name="grabInput" brief="Sends as much input as possible to LOVE.">
      <overload>
        <param name="grab" brief="True to grab, false to ungrab." />
        When grabbing is on, the mouse is confined to the window,
        and as much keyboard input as possible is passed directly to the current game.
        Some key combinations may still be interpreted by the window manager, such
        as Alt+Tab, Ctrl+Alt+Delete, etc.
      </overload>
    </func>
  </module>

  <callback name="load" brief="Called when the game should load.">
    This function is called exacly once at the beginning of the game. This is where
    resources such as images and sounds should be loaded.
    <example id="51" />
  </callback>
  <callback name="update" brief="Called each timestep when the game should be updated.">
    This function should update the state of the game according to the time value dt.
    <param name="dt" brief="The time since last update in seconds." />
    <example id="51" />
  </callback>
  <callback name="draw" brief="Called each timestep right after update.">
    This is where you should draw things onto the screen.
    <example id="51" />
  </callback>
  <callback name="mousepressed" brief="Called when the mouse is pressed.">
    <param name="x" brief="The position of the mouse on the x-axis." />
    <param name="y" brief="The position of the mouse on the y-axis." />
    <param name="button" brief="Which button is pressed." />
    <example id="52" />
  </callback>
  <callback name="mousereleased" brief="Called when the mouse is released.">
    <param name="x" brief="The position of the mouse on the x-axis." />
    <param name="y" brief="The position of the mouse on the y-axis." />
    <param name="button" brief="Which button is released." />
    <example id="52" />
  </callback>
  <callback name="keypressed" brief="Called when a key is pressed.">
    <param name="key" brief="The key code of the pressed key." />
    <example id="53" />
  </callback>
  <callback name="keyreleased" brief="Called when a key is released.">
    <param name="key" brief="The key code of the released key." />
    <example id="53" />
  </callback>
  <callback name="joystickpressed" brief="Called when a button on the joystick is pressed.">
    <param name="joystick" brief="The joystick number" />
    <param name="button" brief="The button number" />
  </callback>
  <callback name="joystickreleased" brief="Called when a button on the joystick is released.">
    <param name="joystick" brief="The joystick number" />
    <param name="button" brief="The button number" />
  </callback>

  <misc name="Constants" title="List of constants">
    This is the complete list of constants available in LOVE.
    <item name="love.key_unknown" brief="Represents an unknown key" />
    <item name="love.key_first" />
    <item name="love.key_backspace" brief="Backspace key" />
    <item name="love.key_tab" brief="Tab key" />
    <item name="love.key_clear" />
    <item name="love.key_return" brief="Carriage return key" />
    <item name="love.key_pause" brief="Pause key" />
    <item name="love.key_escape" brief="Escape key" />
    <item name="love.key_space" brief="Spacebar key" />
    <item name="love.key_exclaim" brief="! key" />
    <item name="love.key_quotedbl" />
    <item name="love.key_hash" brief="# key" />
    <item name="love.key_dollar" brief="$ key" />
    <item name="love.key_ampersand" brief="&amp; key" />
    <item name="love.key_quote" brief='" key' />
    <item name="love.key_leftparen" brief="( key" />
    <item name="love.key_rightparen" brief=") key" />
    <item name="love.key_asterisk" brief="* key" />
    <item name="love.key_plus" brief="+ key" />
    <item name="love.key_comma" brief=", key" />
    <item name="love.key_minus" brief="- key" />
    <item name="love.key_period" brief=". key" />
    <item name="love.key_slash" brief="/ key" />
    <item name="love.key_0" brief="0 key" />
    <item name="love.key_1" brief="1 key" />
    <item name="love.key_2" brief="2 key" />
    <item name="love.key_3" brief="3 key" />
    <item name="love.key_4" brief="4 key" />
    <item name="love.key_5" brief="5 key" />
    <item name="love.key_6" brief="6 key" />
    <item name="love.key_7" brief="7 key" />
    <item name="love.key_8" brief="8 key" />
    <item name="love.key_9" brief="9 key" />
    <item name="love.key_colon" brief=": key" />
    <item name="love.key_semicolon" brief="; key" />
    <item name="love.key_less" brief="&lt; key" />
    <item name="love.key_equals" brief="= key" />
    <item name="love.key_greater" brief="&gt; key" />
    <item name="love.key_question" brief="? key" />
    <item name="love.key_at" brief="@ key" space="true" />

    <item name="love.key_leftbracket" brief="[ key" />
    <item name="love.key_backslash" brief="\ key" />
    <item name="love.key_rightbracket" brief="] key" />
    <item name="love.key_caret" brief="^ key" />
    <item name="love.key_underscore" brief="_ key" />
    <item name="love.key_backquote" brief=" key" />
    <item name="love.key_a" brief="A key" />
    <item name="love.key_b" brief="B key" />
    <item name="love.key_c" brief="C key" />
    <item name="love.key_d" brief="D key" />
    <item name="love.key_e" brief="E key" />
    <item name="love.key_f" brief="F key" />
    <item name="love.key_g" brief="G key" />
    <item name="love.key_h" brief="H key" />
    <item name="love.key_i" brief="I key" />
    <item name="love.key_j" brief="J key" />
    <item name="love.key_k" brief="K key" />
    <item name="love.key_l" brief="L key" />
    <item name="love.key_m" brief="M key" />
    <item name="love.key_n" brief="N key" />
    <item name="love.key_o" brief="O key" />
    <item name="love.key_p" brief="P key" />
    <item name="love.key_q" brief="Q key" />
    <item name="love.key_r" brief="R key" />
    <item name="love.key_s" brief="S key" />
    <item name="love.key_t" brief="T key" />
    <item name="love.key_u" brief="U key" />
    <item name="love.key_v" brief="V key" />
    <item name="love.key_w" brief="W key" />
    <item name="love.key_x" brief="X key" />
    <item name="love.key_y" brief="Y key" />
    <item name="love.key_z" brief="Z key" />
    <item name="love.key_delete" brief="Delete key" space="true" />

    <item name="love.key_kp0" brief="Keypad 0" />
    <item name="love.key_kp1" brief="Keypad 1" />
    <item name="love.key_kp2" brief="Keypad 2" />
    <item name="love.key_kp3" brief="Keypad 3" />
    <item name="love.key_kp4" brief="Keypad 4" />
    <item name="love.key_kp5" brief="Keypad 5" />
    <item name="love.key_kp6" brief="Keypad 6" />
    <item name="love.key_kp7" brief="Keypad 7" />
    <item name="love.key_kp8" brief="Keypad 8" />
    <item name="love.key_kp9" brief="Keypad 9" />
    <item name="love.key_kp_period" brief="Keypad ." />
    <item name="love.key_kp_divide" brief="Keypad /" />
    <item name="love.key_kp_multiply" brief="Keypad *" />
    <item name="love.key_kp_minus" brief="Keypad -" />
    <item name="love.key_kp_plus" brief="Keypad +" />
    <item name="love.key_kp_enter" brief="Keypad enter" />
    <item name="love.key_kp_equals" brief="Keypad =" space="true" />

    <item name="love.key_up" brief="Up key" />
    <item name="love.key_down" brief="Down key" />
    <item name="love.key_right" brief="Right key" />
    <item name="love.key_left" brief="Left key" />
    <item name="love.key_insert" brief="Insert key" />
    <item name="love.key_home" brief="Home key" />
    <item name="love.key_end" brief="End key" />
    <item name="love.key_pageup" brief="Page Up key" />
    <item name="love.key_pagedown" brief="Page Down key" space="true" />

    <item name="love.key_f1" brief="F1 key" />
    <item name="love.key_f2" brief="F2 key" />
    <item name="love.key_f3" brief="F3 key" />
    <item name="love.key_f4" brief="F4 key" />
    <item name="love.key_f5" brief="F5 key" />
    <item name="love.key_f6" brief="F6 key" />
    <item name="love.key_f7" brief="F7 key" />
    <item name="love.key_f8" brief="F8 key" />
    <item name="love.key_f9" brief="F9 key" />
    <item name="love.key_f10" brief="F10 key" />
    <item name="love.key_f11" brief="F11 key" />
    <item name="love.key_f12" brief="F12 key" />
    <item name="love.key_f13" brief="F13 key" />
    <item name="love.key_f14" brief="F14 key" />
    <item name="love.key_f15" brief="F15 key" space="true" />

    <item name="love.key_numlock" brief="Num lock key" />
    <item name="love.key_capslock" brief="Caps lock key" />
    <item name="love.key_scrollock" brief="Scroll lock key" />
    <item name="love.key_rshift" brief="Right shift key" />
    <item name="love.key_lshift" brief="Left shift key" />
    <item name="love.key_rctrl" brief="Right control key" />
    <item name="love.key_lctrl" brief="Left control key" />
    <item name="love.key_ralt" brief="Right alt key" />
    <item name="love.key_lalt" brief="Left alt key" />
    <item name="love.key_rmeta" brief="Right meta key" />
    <item name="love.key_lmeta" brief="Left meta key" />
    <item name="love.key_rsuper" brief="Right super key" />
    <item name="love.key_lsuper" brief="Left super key" />
    <item name="love.key_mode" brief="Mode key" />
    <item name="love.key_compose" brief="Compose key" space="true" />

    <item name="love.key_help" brief="Help key" />
    <item name="love.key_print" brief="Print key" />
    <item name="love.key_sysreq" brief="System request key" />
    <item name="love.key_break" brief="Break key" />
    <item name="love.key_menu" brief="Menu key" />
    <item name="love.key_power" brief="Power key" />
    <item name="love.key_euro" brief="€ key" />
    <item name="love.key_undo" brief="Undo key" space="true" />

    <item name="love.mouse_left" brief="The left mouse button." />
    <item name="love.mouse_middle" brief="The middle mouse button."  />
    <item name="love.mouse_right" brief="The right mouse button."  />
    <item name="love.mouse_wheelup" brief="Mouse wheel scrolled upwards."  />
    <item name="love.mouse_wheeldown" brief="Mouse wheel scrolled downwards."  space="true" />

    <item name="love.joystick_axis_horizontal" brief="Horizontal joystick axis (0)." />
    <item name="love.joystick_axis_vertical" brief="Verrtical joystick axis (1)." />
    <item name="love.joystick_hat_centered" brief="Viewhat state centered." />
    <item name="love.joystick_hat_up" brief="Viewhat state up." />
    <item name="love.joystick_hat_right" brief="Viewhat state right." />
    <item name="love.joystick_hat_down" brief="Viewhat state down." />
    <item name="love.joystick_hat_left" brief="Viewhat state left." />
    <item name="love.joystick_hat_rightup" brief="Viewhat state right and up." />
    <item name="love.joystick_hat_rightdown" brief="Viewhat state right and down." />
    <item name="love.joystick_hat_leftup" brief="Viewhat state left and up." />
    <item name="love.joystick_hat_leftdown" brief="Viewhat state left and down." space="true" />

    <item name="love.align_left" brief="Align to the left side." />
    <item name="love.align_center" brief="Align in the center (vertically or horizontally)." />
    <item name="love.align_right" brief="Align to the right side." />
    <item name="love.align_top" brief="Align to the top." />
    <item name="love.align_bottom" brief="Align to the bottom." space="true" />

    <item name="love.mode_loop" brief="Loops continuesly." />
    <item name="love.mode_once" brief="Plays once." />
    <item name="love.mode_bounce" brief="Bounces back and forth." space="true" />

    <item name="love.event_message" brief="A message event." />
    <item name="love.event_gui" brief="A GUI event." space="true" />

    <item name="love.blend_normal" brief="Normal blendig mode." />
    <item name="love.blend_additive" brief="Additive blending mode." space="true" />

    <item name="love.color_normal" brief="Normal color mode." />
    <item name="love.color_modulate" brief="Modulation color mode." space="true" />

    <item name="love.file_read" brief="For file reading." />
    <item name="love.file_write" brief="For file writing." />
    <item name="love.file_append" brief="For file appending." space="true" />

    <item name="love.default_font" brief="The default font (Vera)." space="true" />

    <item name="love.draw_line" brief="Draws the primitive using lines." />
    <item name="love.draw_fill" brief="Draws a filled primitive." space="true" />

    <item name="love.line_smooth" brief="Sets the lines as smooth." />
    <item name="love.line_rough" brief="Sets the lines as rough (best when drawing straight 1px wide lines)." space="true" />

    <item name="love.audio_loop" brief="Loops music or sound." />
    <item name="love.audio_mode_mono" brief="Sets the audio mode as mono." />
    <item name="love.audio_mode_stereo" brief="Sets the audio mode as stereo." />
    <item name="love.audio_quality_low" brief="Designates low audio quality (11.025KHz)." />
    <item name="love.audio_quality_medium" brief="Designates medium audio quality (22.050KHz)." />
    <item name="love.audio_quality_high" brief="Designates high audio quality (44.100KHz)." />
    <item name="love.audio_buffer_default" brief="The default buffer size for audio mixing." space="true" />

    <item name="love.image_pad" brief="Used to pad an image upon creation." />
    <item name="love.image_optimize" brief="Used to optimize an image upon creation." />
    <item name="love.image_pad_and_optimize" brief="Used to pad &amp; optimize an image upon creation." space="true"/>

    <item name="love.shape_circle" brief="Represents a CircleShape." />
    <item name="love.shape_polygon" brief="Represents a PolygonShape." />
    <item name="love.joint_distance" brief="Represents a DistanceJoint." />
    <item name="love.joint_revolute" brief="Represents a RevoluteJoint." />
    <item name="love.joint_prismatic" brief="Represents a PrismaticJoint." />
    <item name="love.joint_mouse" brief="Represents a MouseJoint." />

  </misc>
  <misc name="Config Files" title="List of config file attributes" file="configfiles.lua">

    Each game should have a config file that specifies game title, author, version, etc. The name of this file must be "game.conf".
    A full listing of available attributes is presented below. [br /]
    [br /]
    All values are optional, but it is highly recommended to at least include title, author, and [b]love_version[/b].

    <item name="title" type="string" brief="The game title."/>
    <item name="author" type="string" brief="The author of the game."/>
    <item name="width" brief="Display resolution width."/>
    <item name="height" brief="Display resolution height."/>
    <item name="fullscreen" brief="True if fullscreen, false otherwise." />
    <item name="vsync" brief="True if attemt to enable, false otherwise." />
    <item name="fsaa" brief="Number of FSAA-buffers." />
    <item name="display_auto" type="boolean" brief="Set this to false if you want to configure the display in Lua manually." />
    <item name="love_version" type="string" brief="The LOVE-version this game was made for."/>

  </misc>
  
  <misc name="Example List" title="List of Examples" file="elist.lua">
	A list of all examples in the documentation is presented below. All examples are runnable as
	standalone applications, or via the [a href="http://love2d.org/?page=documentation"]example browser[/a].
  </misc>

</nzai>