--
-- SWIGFUSION is a small dirty Lua app which parses generated
-- SWIG wrapper code and adds a few functions to it.
--

Module = {}

function Module:new(name)
    local o = {}
    setmetatable(o, self)
    self.__index = self
    o.name = name or error("Module needs a name.")
    o.dir = "../../src/"..name
    o.fname = o.dir .. "/mod_"..name
    o.output = o.dir.."/mod_"..name..".cpp"
    o.input = o.dir.. "/mod_"..name..".i"
    o.glue = { "// ENHANCED BY SWIGFUSION\n" }-- The entire wrapper.
    o.fusion_log = {}
    local fusion_file = loadfile(o.dir.."/fusion.lua")
    if fusion_file then o.ftab = fusion_file() end
    return o
end

function Module:final()
    local file = io.open(self.output, "w")
    file:write(table.concat(self.glue, "\n"))
    file:close()
end

function Module:swig()
    os.execute("swig.exe -nodefaultctor -lua -c++ -o \""..self.output.."\" \""..self.input.."\"")
end

function Module:getIsType(type)
    return "bool mod_is_"..string.lower(type).."(lua_State * L, int idx)"
end

function Module:getToType(type)
    return "p"..type.." mod_to_"..string.lower(type).."(lua_State * L, int idx)"
end

function Module:getPushType(type)
    return "void mod_push_"..string.lower(type).."(lua_State * L, p"..type.." "..string.lower(type)..")"
end


function Module:header()
    local file = io.open(self.fname..".h", "w")
    file:write([[
/*
* LOVE: Totally Awesome 2D Gaming.
* Website: http://love.sourceforge.net
* Licence: ZLIB/libpng
* Copyright (c) 2006-2008 LOVE Development Team
*
* This file was AUTOGENERATED by swigfusion! Please
* do not edit this file manually.
* 
* @author Anders Ruud / swigfusion
* @date ]] .. os.date("%Y-%m-%d") .. [[

**/

#ifndef LOVE_MOD_FUSION_]]..string.upper(self.name)..[[_H
#define LOVE_MOD_FUSION_]]..string.upper(self.name)..[[_H

]])


    file:write([[
// Function from SWIG which opens the module.
extern "C" {
    int luaopen_mod_]]..self.name..[[(lua_State * L);
}

]])

    if self.types then

        file:write("// Types found:\n")
        -- List types.
        for s,l in pairs(self.types) do
            file:write("// " .. s .. " (" .. l .. ")\n")
        end
        file:write("\n")
    end
    
    if #self.fusion_log > 0 then
        file:write("// Fused: \n")
    
        for i,f in pairs(self.fusion_log) do
            file:write("// " .. f .. "\n")
        end
        file:write("\n")
    end

    file:write("namespace love_"..self.name.."\n")
    file:write("{\n\n")
               
    if self.types then           
    
        for s,l in pairs(self.types) do
            file:write("\t"..self:getIsType(s)..";\n")
            file:write("\t"..self:getToType(s)..";\n")
            file:write("\t"..self:getPushType(s)..";\n")
            file:write("\n")
        end
        
    end -- if self.types
        
    file:write("} // " .. "love_"..self.name)
    
    file:write("\n")
    
    file:write("#endif\n")
        
    file:close()
end

function Module:getTypeName(type)
    return "love_"..self.name.."::p"..type
end

-- Adds stuff to the end of the SWIG-wrapper.
function Module:add()

    if self.types then

    table.insert(self.glue, "namespace love_"..self.name)
    table.insert(self.glue, "{")

    for s,l in pairs(self.types) do

        table.insert(self.glue, "\t" .. self:getIsType(s) .. [[
        
    {
        swig_lua_userdata* usr = 0;
        swig_cast_info *cast = 0;
        usr=(swig_lua_userdata*)lua_touserdata(L,idx);
        if(!usr) return false;
        cast=SWIG_TypeCheckStruct(usr->type,]]..l..[[);
        if(cast) return true;
        return false;
    }
    ]])
    
        table.insert(self.glue, "\t" .. self:getToType(s) .. [[
        
    {
        love_]]..self.name..[[::p]]..s..[[ * arg;
        if(!lua_isuserdata(L,1)) luaL_error(L, "Error, argument is not userdata.");
        if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg,]]..l..[[,0))){
              luaL_error(L, "Error, argument is not type ]]..s..[[.");
        }
        return *arg;
    }
    ]])
    
        table.insert(self.glue, "\t" .. self:getPushType(s) .. [[
        
    {
        ]]..self:getTypeName(s)..[[ * resultptr = new ]]..self:getTypeName(s)..[[((]]..self:getTypeName(s)..[[ &) ]]..string.lower(s)..[[);
        SWIG_NewPointerObj(L,(void *) resultptr,]]..l..[[,1);
    }
    ]])
    
    end
    
    table.insert(self.glue, "}")
    
    end -- if self.types 

end

function Module:fusion(line)
    table.insert(self.glue, line)
    
    -- Check for fusion.
    if self.types then
        for i,t in pairs(self.types) do
            local match = string.find(line, "static swig_lua_method swig_boost_shared_ptr_Sl_love_"..self.name.."_"..i.."_Sg__methods")
            if match then
                if self.ftab and self.ftab.methods and self.ftab.methods[i] then
                    for im, m in pairs(self.ftab.methods[i]) do
                        table.insert(self.glue, "\t{\"" .. im .. "\", love_"..self.name.."::" .. m .. "},")
                        print(" * Fused: " ..i..":".. im .. " => " .. m)
                        table.insert(self.fusion_log,  i..":" .. im .. " => " .. m)
                    end
                end
            end
        end
    end
    
end

function Module:checkType(line)
    -- Check for types.
    local s, e, longname, shortname = string.find(line, "#define (SWIGTYPE_p_boost__shared_ptrT_love_"..self.name.."__(%a*)_t)")
    if shortname then
        print(" + Type: " .. shortname)
        if not self.types then self.types = {} end
        self.types[shortname] = longname
    end
end

-- Parses the output file.
function Module:parse()
    self.file = io.open(self.output, "r+")
    for line in self.file:lines() do
        self:checkType(line)
        self:fusion(line)
    end
    io.close(self.file)
end

function Module:generate()
    print("Generating " .. self.name .. " ...")
    self:swig()
    self:parse()
    self:add()
    self:header()
    self:final()
end

mods = {
    sdltimer = Module:new("sdltimer"),
    sdlmouse = Module:new("sdlmouse"),
    sdlmixer = Module:new("sdlmixer"),
    sdlkeyboard = Module:new("sdlkeyboard"),
    opengl = Module:new("opengl"),
    physfs = Module:new("physfs"),
    system = Module:new("system"),
    chipmunk = Module:new("chipmunk"),
}

-- If there's a param,
-- process only that module.
if arg[1] then
    mods[arg[1]]:generate()
else
    -- Process all.
    for i,m in pairs(mods) do
        m:generate()
    end
end

